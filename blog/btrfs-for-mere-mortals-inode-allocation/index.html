<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Btrfs for mere mortals: inode allocation | Marcos&#39; Blog</title>
<meta name="keywords" content="">
<meta name="description" content="Describe how btrfs manages its inodes when compared to other Linux filesystems, from the inside.">
<meta name="author" content="Marcos Paulo de Souza">
<link rel="canonical" href="https://mpdesouza.com/blog/btrfs-for-mere-mortals-inode-allocation/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.b4e19c453811e60acfec1f00c15ac2be1c53f6ab90187e684358ce7faaf48bab.css" integrity="sha256-tOGcRTgR5grP7B8AwVrCvhxT9quQGH5oQ1jOf6r0i6s=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.b95bacdc39e37a332a9f883b1e78be4abc1fdca2bc1f2641f55e3cd3dabd4d61.js" integrity="sha256-uVus3DnjejMqn4g7Hni&#43;Srwf3KK8HyZB9V4809q9TWE="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://mpdesouza.com/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://mpdesouza.com/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://mpdesouza.com/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://mpdesouza.com/apple-touch-icon.png">
<link rel="mask-icon" href="https://mpdesouza.com/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-LWD0KKCW2G"></script>
<script>
var doNotTrack = false;
if (!doNotTrack) {
	window.dataLayer = window.dataLayer || [];
	function gtag(){dataLayer.push(arguments);}
	gtag('js', new Date());
	gtag('config', 'G-LWD0KKCW2G', { 'anonymize_ip': false });
}
</script>
<meta property="og:title" content="Btrfs for mere mortals: inode allocation" />
<meta property="og:description" content="Describe how btrfs manages its inodes when compared to other Linux filesystems, from the inside." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://mpdesouza.com/blog/btrfs-for-mere-mortals-inode-allocation/" /><meta property="article:section" content="blog" />
<meta property="article:published_time" content="2022-04-25T13:30:25-03:00" />
<meta property="article:modified_time" content="2022-04-25T13:30:25-03:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Btrfs for mere mortals: inode allocation"/>
<meta name="twitter:description" content="Describe how btrfs manages its inodes when compared to other Linux filesystems, from the inside."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Blog",
      "item": "https://mpdesouza.com/blog/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "Btrfs for mere mortals: inode allocation",
      "item": "https://mpdesouza.com/blog/btrfs-for-mere-mortals-inode-allocation/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Btrfs for mere mortals: inode allocation",
  "name": "Btrfs for mere mortals: inode allocation",
  "description": "Describe how btrfs manages its inodes when compared to other Linux filesystems, from the inside.",
  "keywords": [
    
  ],
  "articleBody": "It’s known that btrfs behaves differently from other Linux filesystems. There are some fascinating aspects of how btrfs manages its internal structures and how common tools are not prepared to handle it.\nThis goal of this post is to demystify why ext4 can report the number of available inodes while btrfs always reports 0:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 $ file ext4.disk ext4.disk: Linux rev 1.0 ext4 filesystem data, UUID=3f21312b-412a-4b1a-8561-5704eaf39d22 (extents) (64bit) (large files) (huge files) $ mount ext4.disk /mnt $ df -i /mnt Filesystem Inodes IUsed IFree IUse% Mounted on /dev/loop0 327680 11 327669 1% /mnt $ mount -l | grep sda2 /dev/sda2 on / type btrfs (rw,relatime,ssd,space_cache=v2,subvolid=266,subvol=/@/.snapshots/1/snapshot) $ df -i / Filesystem Inodes IUsed IFree IUse% Mounted on /dev/sda2 0 0 0 - / Why btrfs always shows the number of available inodes as zero? This aspect tells a lot about how btrfs manages its physical space.\nFilesystems like ext4 allocate the entire disk on filesystem creation time, creating block groups all over the available space. This means that once the spaces for data and metadata are defined, they cannot be changed after the filesystem is in use, as there isn’t a way to extend them: they have fixed offsets. Let’s take a look how it works for ext4.\nExt4: block sizes and block groups In filesystems, a block is a group of sectors (512 bytes) and it’s the smaller unit of data managed by the filesystem. The block size affects all other filesystem structures, specially in filesystems like ext4 for example. By the block size we can say how many inodes and how much space a ext4 filesystem can manage. Ext4 accepts block sizes of 1k, 2k, 4k and 64k.\nA block group, as the name implies, is a collection of blocks, and many filesystems manage their spaces using block groups. Ext4 divides the entire disk into block groups when creating the filesystem and its size is defined by the block size. By default, ext4 uses blocks of 4k of size. Ext4 stores both data and metadata in a block group.\nFrom now on we’ll make the calculations based in a block size of 4k (4096 bytes).\nTo track which blocks are used in a block group, ext4 reserves one block of the block group to store a bitmap. Each bit of the bitmap will track one block of the block group, meaning that we can map up to 128mb of space:\n4096 bytes * 8bits: 32768 bits 32768 bits can map 32768 blocks of 4k 32768 * 4k: 134217728 bytes: 128Mb Let’s take a look in how ext4 divides a 5G disk, using the default 4k block sizes:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 # create a 5G file to be used as disk $ fallocate -l5g ext4.disk # create the ext4 filesystem on it $ mkfs.ext4 ext4.disk mke2fs 1.43.8 (1-Jan-2018) Discarding device blocks: done Creating filesystem with 1310720 4k blocks and 327680 inodes Filesystem UUID: e408e28f-f275-49c6-87e8-18104fe31ba4 Superblock backups stored on blocks: 32768, 98304, 163840, 229376, 294912, 819200, 884736 Allocating group tables: done Writing inode tables: done Creating journal (16384 blocks): done Writing superblocks and filesystem accounting information: done # print some information about the created filesystem $ dumpe2fs ext4.disk dumpe2fs 1.43.8 (1-Jan-2018) Filesystem volume name: Last mounted on: Filesystem UUID: e408e28f-f275-49c6-87e8-18104fe31ba4 Filesystem magic number: 0xEF53 Filesystem revision #: 1 (dynamic) Filesystem features: has_journal ext_attr resize_inode dir_index filetype extent 64bit flex_bg sparse_super large_file huge_file uninit_bg dir_nlink extra_isize Filesystem flags: signed_directory_hash Default mount options: user_xattr acl Filesystem state: clean Errors behavior: Continue Filesystem OS type: Linux Inode count: 327680 Block count: 1310720 Reserved block count: 65536 Free blocks: 1268642 Free inodes: 327669 First block: 0 Block size: 4096 Fragment size: 4096 Group descriptor size: 64 Reserved GDT blocks: 639 Blocks per group: 32768 Fragments per group: 32768 Inodes per group: 8192 Inode blocks per group: 512 Flex block group size: 16 Filesystem created: Wed Aug 4 00:24:49 2021 ... First inode: 11 Inode size: 256 ... Group 0: (Blocks 0-32767) csum 0xcef6 [ITABLE_ZEROED] Primary superblock at 0, Group descriptors at 1-1 Reserved GDT blocks at 2-640 Block bitmap at 641 (+641) Inode bitmap at 657 (+657) Inode table at 673-1184 (+673) 23897 free blocks, 8181 free inodes, 2 directories, 8181 unused inodes Free blocks: 8871-32767 Free inodes: 12-8192 Group 1: (Blocks 32768-65535) csum 0x4873 [INODE_UNINIT, BLOCK_UNINIT, ITABLE_ZEROED] Backup superblock at 32768, Group descriptors at 32769-32769 Reserved GDT blocks at 32770-33408 Block bitmap at 642 (bg #0 + 642) Inode bitmap at 658 (bg #0 + 658) Inode table at 1185-1696 (bg #0 + 1185) 32127 free blocks, 8192 free inodes, 0 directories, 8192 unused inodes Free blocks: 33409-65535 Free inodes: 8193-16384 ... Group 39: (Blocks 1277952-1310719) csum 0x71eb [INODE_UNINIT, ITABLE_ZEROED] Block bitmap at 1048583 (bg #32 + 7) Inode bitmap at 1048591 (bg #32 + 15) Inode table at 1052176-1052687 (bg #32 + 3600) 32768 free blocks, 8192 free inodes, 0 directories, 8192 unused inodes Free blocks: 1277952-1310719 Free inodes: 319489-327680 The output of mkfs.ext4 was reduced because it’s too long. The output above gives a general idea about how the filesystem is organized. From now on this post will describe how these values are calculated, and why they were chosen by ext4.\nAs ext4 manages its spaces using block groups, and with 4k block sizes we can have a block group mapping up to 128Mb of space, mkfs.ext4 needed to create 40 block groups:\n5G of space / 128mb block group size: 40 block groups Ext4: inodes As mentioned before ext4 uses a reserved block in a block group to track the used blocks. This is also true for inodes. There is a reserved block per block group used as an inode bitmap to track allocated inodes. By using the same math, the inode bitmap can track up to 32768 inodes.\nAlong with the inode bitmap, we also need to store the inode metadata (size, owner, file size, etc). There is a space in the block group to store the inode metadata, and it’s separated from the file’s data.\nAs each block group is allocated when creating the filesystem, and inode metadata has to have a separated space within the block group (called inode table) it needs to calculate the necessary space to store the metadata.\nIf a big amount of space is used to store inode metadata, the filesystem would be able to create more files, but the available space for file content (data) would be reduced. On the other hand, creating a small inode table allows the user to store more data, but with a reduced number of files. To address these limits, mkfs.ext4 uses a configuration called inode-ratio which defines the number of inodes proportional to the storage space. The default inode-ratio is 16k (described in mke2fs.conf file).\nUsing our 5G disk as before and the inode-ration, we can calculate the maximum number of inodes this filesystem can store:\n5G of storage / 16k: 327680 inodes 327680 inodes / 40 block groups: 8192 These values match the output from mkfs.ext4 shown before.\nThe inode table needs to known how much space will be used to store the inode metadata for each inode in the filesystem. Ext4 uses 256 bytes as default inode size (also described in mke2fs.conf file), so for each block group it will use 2Mb of space for the inode table:\n8192 inodes x 256 bytes per inode: 2Mb (2097152 bytes) To compare the numbers, just mount the filesystem created before and use df to show the maximum number of inodes:\n1 2 3 4 5 6 7 $ mount ext4.disk /tmp/ext4 $ df -i /tmp/ext4 Filesystem Inodes IUsed IFree IUse% Mounted on /dev/loop0 327680 11 327669 1% /tmp/ext4 $ ls -i /tmp/ext4 11 lost+found Ext4 reserves the inode numbers from 0 to 10 for special purposes, and the first usable one is for the lost+found. This is a special purpose directory for the ext4 filesystem. All user files start from inode 12.\nFor more information about ext4 block group please check the official ext4 documentation here.\nWhat about btrfs? Btrfs allocates its structures dynamically. From block groups to internal structures and inodes, btrfs allocates them on demand.\nBtrfs: block groups Btrfs also uses block groups to manage the filesystem space, but each block group will store data OR metadata, not both. On filesystem creation time we can specify the block groups to be mixed, containing both data and metadata, but it’s not recommended.\nWhen creating a filesystem btrfs creates a block group to store data, one to store metadata, and one system block group. A data block group (usually) takes 1G of size, while the metadata one can take 256Mb if the filesystem is smaller than 50G, and 1G if bigger. The system block group usually takes up to some megabytes. For small filesystems, the block group sizes cannot be more than 10% of the filesystem size, so it can smaller than 1G as stated before. All the remaining space is left there to be allocated when necessary.\nDifferently from ext4, btrfs allocates block groups on demand. If the workload is focused on data (bigger files), more data block groups will be allocated from the free space. In the same way, if the workload is creating more metadata (doing snapshots for example) more metadata block groups will be allocated.\nLet’s see an example:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 # create a 55G file to be used as disk $ fallocate -l55g btrfs.disk # Create the filesystem on top of it $ mkfs.btrfs -f /storage/btrfs.disk btrfs-progs v5.10.1 See http://btrfs.wiki.kernel.org for more information. Label: (null) UUID: 8f9303a9-15cd-4709-848e-38f80b5b2985 Node size: 16384 Sector size: 4096 Filesystem size: 55.00GiB Block group profiles: Data: single 1.00GiB Metadata: DUP 1.00GiB System: DUP 8.00MiB SSD detected: no Zoned device: no Incompat features: extref, skinny-metadata Runtime features: Checksum: crc32c Number of devices: 1 Devices: ID SIZE PATH 1 55.00GiB /storage/btrfs.disk If your filesystem reports a different data block group as being of 8M, it’s because of this issue that was reported, but maybe not yet fixed. It’s important to understand that these numbers reflect the allocation strategy for single profile. For raid setups, these numbers can be different.\nAlso, the block group sizes doesn’t affect the number of maximum number of inodes that can be created, as we’ll see later.\nWe can inspect the block groups by using the btrfs tool:\n1 2 3 4 5 6 7 8 $ btrfs inspect-internal dump-tree -t extent /storage/btrfs.disk | grep -A1 BLOCK_GROUP item 0 key (1078984704 BLOCK_GROUP_ITEM 1073741824) itemoff 16259 itemsize 24 block group used 0 chunk_objectid 256 flags DATA item 1 key (2152726528 BLOCK_GROUP_ITEM 8388608) itemoff 16235 itemsize 24 block group used 16384 chunk_objectid 256 flags SYSTEM|DUP ... item 4 key (2161115136 BLOCK_GROUP_ITEM 1073741824) itemoff 16145 itemsize 24 block group used 114688 chunk_objectid 256 flags METADATA|DUP The above command used the inspect-internal subcommand to dump the entire extent-tree. We can compare the block group sizes (the numbers after the BLOCK_GROUP_ITEM) in bytes that match we the previous mkfs.btrfs output. The profiles are also dumped and can be verified, being DUP for system and metadata.\nWhen we write more files, or if a file occupies more than 1G of data, more data block groups are created (the flags field shows the type of the block group):\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 # Creating a 2.5G file $ dd if=/dev/urandom of=/mnt/testing/file.bin bs=1M count=2500 $ sync # Check the new data block groups $ btrfs inspect-internal dump-tree -t extent /storage/btrfs.disk| grep -A1 BLOCK_GROUP item 0 key (1078984704 BLOCK_GROUP_ITEM 1073741824) itemoff 16259 itemsize 24 block group used 940572672 chunk_objectid 256 flags DATA .. item 13 key (2152726528 BLOCK_GROUP_ITEM 8388608) itemoff 15619 itemsize 24 block group used 16384 chunk_objectid 256 flags SYSTEM|DUP item 14 key (2161115136 BLOCK_GROUP_ITEM 1073741824) itemoff 15595 itemsize 24 block group used 2899968 chunk_objectid 256 flags METADATA|DUP .. item 192 key (3234856960 BLOCK_GROUP_ITEM 1073741824) itemoff 9730 itemsize 24 block group used 939524096 chunk_objectid 256 flags DATA .. item 201 key (4308598784 BLOCK_GROUP_ITEM 1073741824) itemoff 9282 itemsize 24 block group used 742391808 chunk_objectid 256 flags DATA We can see that new data block groups were created. If we remove the file, the used space is updated to reflect the file removal:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 $ rm /mnt/testing/file.bin $ sync $ btrfs inspect-internal dump-tree -t extent /storage/btrfs.disk| grep -A1 BLOCK_GROUP item 1 key (1078984704 BLOCK_GROUP_ITEM 1073741824) itemoff 16206 itemsize 24 block group used 1048576 chunk_objectid 256 flags DATA .. item 6 key (2152726528 BLOCK_GROUP_ITEM 8388608) itemoff 15990 itemsize 24 block group used 16384 chunk_objectid 256 flags SYSTEM|DUP item 7 key (2161115136 BLOCK_GROUP_ITEM 1073741824) itemoff 15966 itemsize 24 block group used 147456 chunk_objectid 256 flags METADATA|DUP .. item 17 key (3234856960 BLOCK_GROUP_ITEM 1073741824) itemoff 15645 itemsize 24 block group used 0 chunk_objectid 256 flags DATA item 18 key (4308598784 BLOCK_GROUP_ITEM 1073741824) itemoff 15621 itemsize 24 block group used 0 chunk_objectid 256 flags DATA Take a look in the block group use field, they are now zeroed. The block groups are still allocated, but a balance can remove the non used ones:\n1 2 3 4 5 6 7 8 9 10 11 $ btrfs balance start -dusage=0 /mnt/testing Done, had to relocate 0 out of 3 chunks $ btrfs inspect-internal dump-tree -textent /storage/btrfs.disk | grep -A 1 BLOCK_GROUP item 0 key (1078984704 BLOCK_GROUP_ITEM 1073741824) itemoff 16259 itemsize 24 block group used 524288 chunk_objectid 256 flags DATA .. item 3 key (2152726528 BLOCK_GROUP_ITEM 8388608) itemoff 16129 itemsize 24 block group used 16384 chunk_objectid 256 flags SYSTEM|DUP .. item 5 key (2161115136 BLOCK_GROUP_ITEM 1073741824) itemoff 16072 itemsize 24 block group used 147456 chunk_objectid 256 flags METADATA|DUP It shows only one data block group.\nBtrfs: inodes Btrfs does not use fixes inode bitmaps for inode allocation. As stated before, btrfs allocates internal items to manage its metadata. Each item is addressed by three values that together compose a key. These values are described as objectid, type and offset.\nThis is the fs tree right after the filesystem is created:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 $ btrfs inspect-internal dump-tree -t fs /storage/btrfs.disk btrfs-progs v5.16.1 fs tree key (FS_TREE ROOT_ITEM 0) leaf 30474240 items 2 free space 16061 generation 5 owner FS_TREE leaf 30474240 flags 0x1(WRITTEN) backref revision 1 fs uuid b62385e4-e0cc-497f-a220-29ae6465510d chunk uuid b3e0fa4d-fddb-40b3-bd9c-349df8095b39 item 0 key (256 INODE_ITEM 0) itemoff 16123 itemsize 160 generation 3 transid 0 size 0 nbytes 16384 block group 0 mode 40755 links 1 uid 0 gid 0 rdev 0 sequence 0 flags 0x0(none) atime 1650811378.0 (2022-04-24 11:42:58) ctime 1650811378.0 (2022-04-24 11:42:58) mtime 1650811378.0 (2022-04-24 11:42:58) otime 1650811378.0 (2022-04-24 11:42:58) item 1 key (256 INODE_REF 256) itemoff 16111 itemsize 12 index 0 namelen 2 name: .. There are two items in the listing, and the two refer to the top level directory. The INODE_ITEM item contains data about the inode, owner, size and etc. Its key is always (inode_number INODE_ITEM 0), and 256 is the first inode number used in a filesystem tree.\nThe INODE_REF item maps an inode to its parent directory (inode_number INODE_REF parent_dir_inode). In this case it points to itself since the top level directory ancestor is itself.\nBy creating a file, we can see more structures being allocated:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 $ touch /mnt/testing/file.txt $ sync $ btrfs inspect-internal dump-tree -t fs /storage/btrfs.disk ... item 2 key (256 DIR_ITEM 3956591618) itemoff 16073 itemsize 38 location key (257 INODE_ITEM 0) type FILE transid 9 data_len 0 name_len 8 name: file.txt item 3 key (256 DIR_INDEX 2) itemoff 16035 itemsize 38 location key (257 INODE_ITEM 0) type FILE transid 9 data_len 0 name_len 8 name: file.txt item 4 key (257 INODE_ITEM 0) itemoff 15875 itemsize 160 generation 9 transid 9 size 0 nbytes 0 block group 0 mode 100644 links 1 uid 0 gid 0 rdev 0 sequence 10 flags 0x0(none) atime 1650811865.463886516 (2022-04-24 11:51:05) ctime 1650811865.463886516 (2022-04-24 11:51:05) mtime 1650811865.463886516 (2022-04-24 11:51:05) otime 1650811865.463886516 (2022-04-24 11:51:05) item 5 key (257 INODE_REF 256) itemoff 15857 itemsize 18 index 2 namelen 8 name: file.txt A new INODE_ITEM was allocated for file.txt, using the inode number 257. The new INODE_REF item’s offset points to 256, which is the top level directory, as expected.\nTwo new items are also allocated: DIR_ITEM and DIR_INDEX. DIR_INDEX is used for directory listing, like readdir for example. Its key (parent_dir_inode DIR_INDEX pos) almost explains itself. The pos value says it’s the third file created in the directory, as values 1 and 2 are related to ‘.’ and ‘..’ respectively. DIR_ITEM is used for searching. Its offset value is the filename hashed, making it quick to find a file by name inside a directory.\nAs the file grows, more item are created:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 $ dd if=/dev/urandom of=/mnt/testing/file.txt bs=1M count=500 $ sync $ btrfs inspect-internal dump-tree -t fs btrfs.disk ... item 6 key (257 EXTENT_DATA 0) itemoff 15804 itemsize 53 generation 12 type 1 (regular) extent data disk byte 1104150528 nr 134217728 extent data offset 0 nr 134217728 ram 134217728 extent compression 0 (none) item 7 key (257 EXTENT_DATA 134217728) itemoff 15751 itemsize 53 generation 12 type 1 (regular) extent data disk byte 1238368256 nr 134217728 extent data offset 0 nr 134217728 ram 134217728 extent compression 0 (none) item 8 key (257 EXTENT_DATA 268435456) itemoff 15698 itemsize 53 generation 12 type 1 (regular) extent data disk byte 1372585984 nr 134217728 extent data offset 0 nr 134217728 ram 134217728 extent compression 0 (none) item 9 key (257 EXTENT_DATA 402653184) itemoff 15645 itemsize 53 generation 12 type 1 (regular) extent data disk byte 1506803712 nr 90177536 extent data offset 0 nr 90177536 ram 90177536 extent compression 0 (none) item 10 key (257 EXTENT_DATA 492830720) itemoff 15592 itemsize 53 generation 12 type 1 (regular) extent data disk byte 1596981248 nr 1048576 extent data offset 0 nr 1048576 ram 1048576 extent compression 0 (none) item 11 key (257 EXTENT_DATA 493879296) itemoff 15539 itemsize 53 generation 12 type 1 (regular) extent data disk byte 1598029824 nr 30408704 extent data offset 0 nr 30408704 ram 30408704 extent compression 0 (none) ... New EXTENT_DATA items are created to manage the data related to user files. The objectid of the EXTENT_DATA’s key informs to which inode the data is associated.\nMore data about btrfs item can be found in this document.\nWhy can’t btrfs show how many inodes it can hold? Because it’s impossible to known beforehand.\nThe same metadata block group space is used to store INODE_ITEM, EXTENT_DATA and all other metadata items. So if a workload creates bigger files, it ends ups creating more EXTENT_DATA items, which can end up consuming a huge number of metadata block groups to manage extents.\nOn the other hand, if your workload ends up creating a huge number of small files, it would end up creating less EXTENT_DATA items, making it possible to store different items, including INODE_ITEMs, making it possible to create more files.\nThat’s the reason for the number of inodes cannot be checked by using df. The df tool uses the statfs system call to show the information about inodes. The system call populates the statfs struct with the values related to the filesystem being checked, and the f_files field contains the maximum number of inodes.\nBy looking at the kernel code, the function btrfs_statfs does not set buf-\u003ef_files, while in ext4_statfs we can see the information being get from the superblock.\nBtrfs: Inodes and subvolumes In btrfs, subvolumes store user data, and act like different filesystems, as each subvolume can be mounted separately. It can be compared to a disk partition, but having much more features, like creating snapshots. openSUSE and SUSE Linux Enterprise (SLE) uses subvolumes to divide the filesystem into logic structures, and also to manage snapshots after each upgrade:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 $ btrfs subvolume list / [sudo] password for root: ID 256 gen 31 top level 5 path @ ID 257 gen 161195 top level 256 path @/var ID 258 gen 161097 top level 256 path @/usr/local ID 259 gen 64676 top level 256 path @/srv ID 260 gen 149398 top level 256 path @/root ID 261 gen 146119 top level 256 path @/opt ID 262 gen 161195 top level 256 path @/home ID 263 gen 150062 top level 256 path @/boot/grub2/x86_64-efi ID 264 gen 27 top level 256 path @/boot/grub2/i386-pc ID 265 gen 160386 top level 256 path @/.snapshots ID 266 gen 161162 top level 265 path @/.snapshots/1/snapshot ID 342 gen 110017 top level 265 path @/.snapshots/77/snapshot ID 343 gen 110254 top level 265 path @/.snapshots/78/snapshot ID 346 gen 112147 top level 265 path @/.snapshots/81/snapshot ID 347 gen 112149 top level 265 path @/.snapshots/82/snapshot ID 352 gen 113071 top level 265 path @/.snapshots/87/snapshot ID 353 gen 113100 top level 257 path @/var/lib/machines ... An interesting fact about subvolumes is that files always start from inode 257, and the same inode numbers are used in different subvolumes. Since each subvolume is a different tree inside btrfs, it’s not a problem for the end user. Let’s see an example of this happening:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 $ mount /storage/btrfs.disk /mnt/testing $ btrfs subvolume create /mnt/testing/vol1 Create subvolume '/mnt/testing/vol1' $ btrfs subvolume create /mnt/testing/vol2 Create subvolume '/mnt/testing/vol2' # let's create directories and files inside each subvolume $ touch /mnt/testing/vol1/file1 $ touch /mnt/testing/vol1/file2 $ mkdir /mnt/testing/vol2/dir1 $ touch /mnt/testing/vol2/filexx # let's list the inodes of there files/direcotry $ ls -iR /mnt/testing /mnt/testing: 256 vol1 256 vol2 /mnt/testing/vol1: 257 file1 258 file2 /mnt/testing/vol2: 257 dir1 258 filexx /mnt/testing/vol2/dir1: From the output above we can see that both file1 and dir, and file2 and filexx have the same inode numbers.\nConsiderations Interested readers may want to take a look into the ext4 kernel documentation , the mke2fs documentation and the configuration file used by mke2fs for the default filesystem settings.\nBtrfs has a nice wiki page detailing how things work. Additional info can be get from the mkfs.btrfs utility man page and for the more curious readers, the btrfs-dev-docs details the inner parts of the filesystem.\nThe post got much bigger than I expected. The initial focus was to only mention about the kernel code setting the number of inodes in ex4, and the math involved to find the maximum number of inodes. While talking with some friends, it became more evident that more background would be more interesting. So that explains why block groups, subvolumes and everything in between was mentioned.\nThanks for reading!\n",
  "wordCount" : "3941",
  "inLanguage": "en",
  "datePublished": "2022-04-25T13:30:25-03:00",
  "dateModified": "2022-04-25T13:30:25-03:00",
  "author":{
    "@type": "Person",
    "name": "Marcos Paulo de Souza"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://mpdesouza.com/blog/btrfs-for-mere-mortals-inode-allocation/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Marcos' Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://mpdesouza.com/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://mpdesouza.com" accesskey="h" title="Marcos&#39; Blog (Alt + H)">Marcos&#39; Blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="https://mpdesouza.com/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="https://mpdesouza.com/about-me/" title="About Me">
                    <span>About Me</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://mpdesouza.com">Home</a>&nbsp;»&nbsp;<a href="https://mpdesouza.com/blog/">Blog</a></div>
    <h1 class="post-title">
      Btrfs for mere mortals: inode allocation
    </h1>
    <div class="post-description">
      Describe how btrfs manages its inodes when compared to other Linux filesystems, from the inside.
    </div>
    <div class="post-meta"><span title='2022-04-25 13:30:25 -0300 -0300'>April 25, 2022</span>&nbsp;·&nbsp;19 min&nbsp;·&nbsp;Marcos Paulo de Souza

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#why-btrfs-always-shows-the-number-of-available-inodes-as-zero" aria-label="Why btrfs always shows the number of available inodes as zero?">Why btrfs always shows the number of available inodes as zero?</a><ul>
                        
                <li>
                    <a href="#ext4-block-sizes-and-block-groups" aria-label="Ext4: block sizes and block groups">Ext4: block sizes and block groups</a></li>
                <li>
                    <a href="#ext4-inodes" aria-label="Ext4: inodes">Ext4: inodes</a></li></ul>
                </li>
                <li>
                    <a href="#what-about-btrfs" aria-label="What about btrfs?">What about btrfs?</a><ul>
                        
                <li>
                    <a href="#btrfs-block-groups" aria-label="Btrfs: block groups">Btrfs: block groups</a></li>
                <li>
                    <a href="#btrfs-inodes" aria-label="Btrfs: inodes">Btrfs: inodes</a></li>
                <li>
                    <a href="#why-cant-btrfs-show-how-many-inodes-it-can-hold" aria-label="Why can&amp;rsquo;t btrfs show how many inodes it can hold?"><em>Why can&rsquo;t btrfs show how many inodes it can hold?</em></a></li></ul>
                </li>
                <li>
                    <a href="#btrfs-inodes-and-subvolumes" aria-label="Btrfs: Inodes and subvolumes">Btrfs: Inodes and subvolumes</a><ul>
                        
                <li>
                    <a href="#considerations" aria-label="Considerations">Considerations</a>
                </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><p>It&rsquo;s known that btrfs behaves differently from other Linux filesystems. There
are some fascinating aspects of how btrfs manages its internal structures and
how common tools are not prepared to handle it.</p>
<p>This goal of this post is to demystify why ext4 can report the number of
available inodes while btrfs always reports 0:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">$ file ext4.disk                                                               
</span></span><span class="line"><span class="cl">ext4.disk: Linux rev 1.0 ext4 filesystem data, <span class="nv">UUID</span><span class="o">=</span>3f21312b-412a-4b1a-8561-5704eaf39d22 <span class="o">(</span>extents<span class="o">)</span> <span class="o">(</span>64bit<span class="o">)</span> <span class="o">(</span>large files<span class="o">)</span> <span class="o">(</span>huge files<span class="o">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$ mount ext4.disk /mnt
</span></span><span class="line"><span class="cl">$ df -i /mnt    
</span></span><span class="line"><span class="cl">Filesystem     Inodes IUsed  IFree IUse% Mounted on
</span></span><span class="line"><span class="cl">/dev/loop0     <span class="m">327680</span>    <span class="m">11</span> <span class="m">327669</span>    1% /mnt
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$ mount -l <span class="p">|</span> grep sda2
</span></span><span class="line"><span class="cl">/dev/sda2 on / <span class="nb">type</span> btrfs <span class="o">(</span>rw,relatime,ssd,space_cache<span class="o">=</span>v2,subvolid<span class="o">=</span>266,subvol<span class="o">=</span>/@/.snapshots/1/snapshot<span class="o">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$ df -i /
</span></span><span class="line"><span class="cl">Filesystem     Inodes IUsed IFree IUse% Mounted on
</span></span><span class="line"><span class="cl">/dev/sda2           <span class="m">0</span>     <span class="m">0</span>     <span class="m">0</span>     - /
</span></span></code></pre></td></tr></table>
</div>
</div><h1 id="why-btrfs-always-shows-the-number-of-available-inodes-as-zero">Why btrfs always shows the number of available inodes as zero?<a hidden class="anchor" aria-hidden="true" href="#why-btrfs-always-shows-the-number-of-available-inodes-as-zero">#</a></h1>
<p>This aspect tells a lot about how btrfs manages its physical space.</p>
<p>Filesystems like ext4 allocate the entire disk on filesystem creation
time, creating block groups all over the available space. This means that once
the spaces for data and metadata are defined, they cannot be changed after the
filesystem is in use, as there isn&rsquo;t a way to extend them: they have fixed
offsets. Let&rsquo;s take a look how it works for ext4.</p>
<h2 id="ext4-block-sizes-and-block-groups">Ext4: block sizes and block groups<a hidden class="anchor" aria-hidden="true" href="#ext4-block-sizes-and-block-groups">#</a></h2>
<p>In filesystems, a block is a group of sectors (512 bytes) and it&rsquo;s the smaller
unit of data managed by the filesystem. The block size affects all other
filesystem structures, specially in filesystems like ext4 for example.
By the block size we can say how many inodes and how much space a ext4
filesystem can manage. Ext4 accepts block sizes of 1k, 2k, 4k and 64k.</p>
<p>A block group, as the name implies, is a collection of blocks, and many
filesystems manage their spaces using block groups. Ext4 divides the entire disk
into block groups when creating the filesystem and its size is defined by the
block size. By default, ext4 uses blocks of 4k of size. Ext4 stores both data
and metadata in a block group.</p>
<p>From now on we&rsquo;ll make the calculations based in a block size of 4k (4096
bytes).</p>
<p>To track which blocks are used in a block group, ext4 reserves one block of the
block group to store a <a href="https://en.wikipedia.org/wiki/Bit_array">bitmap</a>.  Each
bit of the bitmap will track one block of the block group, meaning that we
can map up to 128mb of space:</p>
<pre tabindex="0"><code>4096 bytes * 8bits: 32768 bits
32768 bits can map 32768 blocks of 4k
32768 * 4k: 134217728 bytes: 128Mb
</code></pre><p>Let&rsquo;s take a look in how ext4 divides a 5G disk, using the default 4k block
sizes:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl"><span class="c1"># create a 5G file to be used as disk</span>
</span></span><span class="line"><span class="cl">$ fallocate -l5g ext4.disk
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># create the ext4 filesystem on it</span>
</span></span><span class="line"><span class="cl">$ mkfs.ext4 ext4.disk
</span></span><span class="line"><span class="cl">mke2fs 1.43.8 <span class="o">(</span>1-Jan-2018<span class="o">)</span>
</span></span><span class="line"><span class="cl">Discarding device blocks: <span class="k">done</span>
</span></span><span class="line"><span class="cl">Creating filesystem with <span class="m">1310720</span> 4k blocks and <span class="m">327680</span> inodes
</span></span><span class="line"><span class="cl">Filesystem UUID: e408e28f-f275-49c6-87e8-18104fe31ba4
</span></span><span class="line"><span class="cl">Superblock backups stored on blocks:
</span></span><span class="line"><span class="cl">        32768, 98304, 163840, 229376, 294912, 819200, <span class="m">884736</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Allocating group tables: <span class="k">done</span>
</span></span><span class="line"><span class="cl">Writing inode tables: <span class="k">done</span>
</span></span><span class="line"><span class="cl">Creating journal <span class="o">(</span><span class="m">16384</span> blocks<span class="o">)</span>: <span class="k">done</span>
</span></span><span class="line"><span class="cl">Writing superblocks and filesystem accounting information: <span class="k">done</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># print some information about the created filesystem</span>
</span></span><span class="line"><span class="cl">$ dumpe2fs ext4.disk
</span></span><span class="line"><span class="cl">dumpe2fs 1.43.8 <span class="o">(</span>1-Jan-2018<span class="o">)</span>
</span></span><span class="line"><span class="cl">Filesystem volume name:   &lt;none&gt;
</span></span><span class="line"><span class="cl">Last mounted on:          &lt;not available&gt;
</span></span><span class="line"><span class="cl">Filesystem UUID:          e408e28f-f275-49c6-87e8-18104fe31ba4
</span></span><span class="line"><span class="cl">Filesystem magic number:  0xEF53
</span></span><span class="line"><span class="cl">Filesystem revision <span class="c1">#:    1 (dynamic)</span>
</span></span><span class="line"><span class="cl">Filesystem features:      has_journal ext_attr resize_inode dir_index filetype extent 64bit flex_bg sparse_super large_file huge_file uninit_bg dir_nlink extra_isize
</span></span><span class="line"><span class="cl">Filesystem flags:         signed_directory_hash
</span></span><span class="line"><span class="cl">Default mount options:    user_xattr acl
</span></span><span class="line"><span class="cl">Filesystem state:         clean
</span></span><span class="line"><span class="cl">Errors behavior:          Continue
</span></span><span class="line"><span class="cl">Filesystem OS type:       Linux
</span></span><span class="line"><span class="cl">Inode count:              <span class="m">327680</span>
</span></span><span class="line"><span class="cl">Block count:              <span class="m">1310720</span>
</span></span><span class="line"><span class="cl">Reserved block count:     <span class="m">65536</span>
</span></span><span class="line"><span class="cl">Free blocks:              <span class="m">1268642</span>
</span></span><span class="line"><span class="cl">Free inodes:              <span class="m">327669</span>
</span></span><span class="line"><span class="cl">First block:              <span class="m">0</span>
</span></span><span class="line"><span class="cl">Block size:               <span class="m">4096</span>
</span></span><span class="line"><span class="cl">Fragment size:            <span class="m">4096</span>
</span></span><span class="line"><span class="cl">Group descriptor size:    <span class="m">64</span>
</span></span><span class="line"><span class="cl">Reserved GDT blocks:      <span class="m">639</span>
</span></span><span class="line"><span class="cl">Blocks per group:         <span class="m">32768</span>
</span></span><span class="line"><span class="cl">Fragments per group:      <span class="m">32768</span>
</span></span><span class="line"><span class="cl">Inodes per group:         <span class="m">8192</span>
</span></span><span class="line"><span class="cl">Inode blocks per group:   <span class="m">512</span>
</span></span><span class="line"><span class="cl">Flex block group size:    <span class="m">16</span>
</span></span><span class="line"><span class="cl">Filesystem created:       Wed Aug  <span class="m">4</span> 00:24:49 <span class="m">2021</span>
</span></span><span class="line"><span class="cl">...
</span></span><span class="line"><span class="cl">First inode:              <span class="m">11</span>
</span></span><span class="line"><span class="cl">Inode size:               <span class="m">256</span>
</span></span><span class="line"><span class="cl">...
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Group 0: <span class="o">(</span>Blocks 0-32767<span class="o">)</span> csum 0xcef6 <span class="o">[</span>ITABLE_ZEROED<span class="o">]</span>
</span></span><span class="line"><span class="cl">  Primary superblock at 0, Group descriptors at 1-1
</span></span><span class="line"><span class="cl">  Reserved GDT blocks at 2-640
</span></span><span class="line"><span class="cl">  Block bitmap at <span class="m">641</span> <span class="o">(</span>+641<span class="o">)</span>
</span></span><span class="line"><span class="cl">  Inode bitmap at <span class="m">657</span> <span class="o">(</span>+657<span class="o">)</span>
</span></span><span class="line"><span class="cl">  Inode table at 673-1184 <span class="o">(</span>+673<span class="o">)</span>
</span></span><span class="line"><span class="cl">  <span class="m">23897</span> free blocks, <span class="m">8181</span> free inodes, <span class="m">2</span> directories, <span class="m">8181</span> unused inodes
</span></span><span class="line"><span class="cl">  Free blocks: 8871-32767
</span></span><span class="line"><span class="cl">  Free inodes: 12-8192
</span></span><span class="line"><span class="cl">Group 1: <span class="o">(</span>Blocks 32768-65535<span class="o">)</span> csum 0x4873 <span class="o">[</span>INODE_UNINIT, BLOCK_UNINIT, ITABLE_ZEROED<span class="o">]</span>
</span></span><span class="line"><span class="cl">  Backup superblock at 32768, Group descriptors at 32769-32769
</span></span><span class="line"><span class="cl">  Reserved GDT blocks at 32770-33408
</span></span><span class="line"><span class="cl">  Block bitmap at <span class="m">642</span> <span class="o">(</span><span class="nb">bg</span> <span class="c1">#0 + 642)</span>
</span></span><span class="line"><span class="cl">  Inode bitmap at <span class="m">658</span> <span class="o">(</span><span class="nb">bg</span> <span class="c1">#0 + 658)</span>
</span></span><span class="line"><span class="cl">  Inode table at 1185-1696 <span class="o">(</span><span class="nb">bg</span> <span class="c1">#0 + 1185)</span>
</span></span><span class="line"><span class="cl">  <span class="m">32127</span> free blocks, <span class="m">8192</span> free inodes, <span class="m">0</span> directories, <span class="m">8192</span> unused inodes
</span></span><span class="line"><span class="cl">  Free blocks: 33409-65535
</span></span><span class="line"><span class="cl">  Free inodes: 8193-16384
</span></span><span class="line"><span class="cl">...
</span></span><span class="line"><span class="cl">Group 39: <span class="o">(</span>Blocks 1277952-1310719<span class="o">)</span> csum 0x71eb <span class="o">[</span>INODE_UNINIT, ITABLE_ZEROED<span class="o">]</span>
</span></span><span class="line"><span class="cl">  Block bitmap at <span class="m">1048583</span> <span class="o">(</span><span class="nb">bg</span> <span class="c1">#32 + 7)</span>
</span></span><span class="line"><span class="cl">  Inode bitmap at <span class="m">1048591</span> <span class="o">(</span><span class="nb">bg</span> <span class="c1">#32 + 15)</span>
</span></span><span class="line"><span class="cl">  Inode table at 1052176-1052687 <span class="o">(</span><span class="nb">bg</span> <span class="c1">#32 + 3600)</span>
</span></span><span class="line"><span class="cl">  <span class="m">32768</span> free blocks, <span class="m">8192</span> free inodes, <span class="m">0</span> directories, <span class="m">8192</span> unused inodes
</span></span><span class="line"><span class="cl">  Free blocks: 1277952-1310719
</span></span><span class="line"><span class="cl">  Free inodes: 319489-327680
</span></span></code></pre></td></tr></table>
</div>
</div><p>The output of mkfs.ext4 was reduced because it&rsquo;s too long. The output above
gives a general idea about how the filesystem is organized. From now on this
post will describe how these values are calculated, and why they were chosen by
ext4.</p>
<p>As ext4 manages its spaces using block groups, and with 4k block sizes we can
have a block group mapping up to 128Mb of space, mkfs.ext4 needed to create 40
block groups:</p>
<pre tabindex="0"><code>5G of space / 128mb block group size: 40 block groups
</code></pre><h2 id="ext4-inodes">Ext4: inodes<a hidden class="anchor" aria-hidden="true" href="#ext4-inodes">#</a></h2>
<p>As mentioned before ext4 uses a reserved block in a block group to track the
used blocks. This is also true for inodes. There is a reserved block per block
group used as an <em>inode bitmap</em> to track allocated inodes. By using the same
math, the inode bitmap can track up to 32768 inodes.</p>
<p>Along with the <em>inode bitmap</em>, we also need to store the inode metadata (size,
owner, file size, etc). There is a space in the block group to store the inode
metadata, and it&rsquo;s separated from the file&rsquo;s data.</p>
<p>As each block group is allocated when creating the filesystem, and inode
metadata has to have a separated space within the block group (called
<em>inode table</em>) it needs to calculate the necessary space to store the metadata.</p>
<p>If a big amount of space is used to store inode metadata, the filesystem would
be able to create more files, but the available space for file content (data)
would be reduced. On the other hand, creating a small inode table allows the
user to store more data, but with a reduced number of files. To address these
limits, mkfs.ext4 uses a configuration called <em>inode-ratio</em> which defines the
number of inodes proportional to the storage space. The default <em>inode-ratio</em> is
<em>16k</em> (described in
<a href="https://man7.org/linux/man-pages/man5/mke2fs.conf.5.html">mke2fs.conf</a> file).</p>
<p>Using our 5G disk as before and the inode-ration, we can calculate the maximum
number of inodes this filesystem can store:</p>
<pre tabindex="0"><code>5G of storage / 16k: 327680 inodes
327680 inodes / 40 block groups: 8192
</code></pre><p>These values match the output from mkfs.ext4 shown before.</p>
<p>The <em>inode table</em> needs to known how much space will be used to store the inode
metadata for each inode in the filesystem. Ext4 uses 256 bytes as default inode
size (also described in
<a href="https://man7.org/linux/man-pages/man5/mke2fs.conf.5.html">mke2fs.conf</a> file),
so for each block group it will use 2Mb of space for the <em>inode table</em>:</p>
<pre tabindex="0"><code>8192 inodes x 256 bytes per inode: 2Mb (2097152 bytes)
</code></pre><p>To compare the numbers, just mount the filesystem created before and use df to
show the maximum number of inodes:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">$ mount ext4.disk /tmp/ext4
</span></span><span class="line"><span class="cl">$ df -i /tmp/ext4 
</span></span><span class="line"><span class="cl">Filesystem     Inodes IUsed  IFree IUse% Mounted on
</span></span><span class="line"><span class="cl">/dev/loop0     <span class="m">327680</span>    <span class="m">11</span> <span class="m">327669</span>    1% /tmp/ext4
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$ ls -i /tmp/ext4
</span></span><span class="line"><span class="cl"><span class="m">11</span> lost+found
</span></span></code></pre></td></tr></table>
</div>
</div><p>Ext4 reserves the inode numbers from 0 to 10 for special purposes, and the first
usable one is for the <em>lost+found</em>. This is a special purpose directory for the
ext4 filesystem. All user files start from inode 12.</p>
<p>For more information about ext4 block group please check the official ext4
documentation
<a href="https://www.kernel.org/doc/html/latest/filesystems/ext4/overview.html#layout">here</a>.</p>
<h1 id="what-about-btrfs">What about btrfs?<a hidden class="anchor" aria-hidden="true" href="#what-about-btrfs">#</a></h1>
<p>Btrfs allocates its structures dynamically. From block groups to internal
structures and inodes, btrfs allocates them on demand.</p>
<h2 id="btrfs-block-groups">Btrfs: block groups<a hidden class="anchor" aria-hidden="true" href="#btrfs-block-groups">#</a></h2>
<p>Btrfs also uses block groups to manage the filesystem space, but each block
group will store data OR metadata, not both. On filesystem creation time we can
specify the block groups to be <em>mixed</em>, containing both data and metadata,
but it&rsquo;s not recommended.</p>
<p>When creating a filesystem btrfs creates a block group to store data, one to
store metadata, and one <em>system</em> block group. A data block group (usually) takes
1G of size, while the metadata one can take 256Mb if the filesystem is smaller
than 50G, and 1G if bigger. The system block group usually takes up to some
megabytes. For small filesystems, the block group sizes cannot be more than 10%
of the filesystem size, so it can smaller than 1G as stated before. All the
remaining space is left there to be allocated when necessary.</p>
<p>Differently from ext4, btrfs allocates block groups on demand. If the workload
is focused on data (bigger files), more data block groups will be allocated from
the free space. In the same way, if the workload is creating more metadata
(doing snapshots for example) more metadata block groups will be allocated.</p>
<p>Let&rsquo;s see an example:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl"><span class="c1"># create a 55G file to be used as disk</span>
</span></span><span class="line"><span class="cl">$ fallocate -l55g btrfs.disk
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># Create the filesystem on top of it</span>
</span></span><span class="line"><span class="cl">$ mkfs.btrfs -f /storage/btrfs.disk 
</span></span><span class="line"><span class="cl">btrfs-progs v5.10.1 
</span></span><span class="line"><span class="cl">See http://btrfs.wiki.kernel.org <span class="k">for</span> more information.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Label:              <span class="o">(</span>null<span class="o">)</span>
</span></span><span class="line"><span class="cl">UUID:               8f9303a9-15cd-4709-848e-38f80b5b2985
</span></span><span class="line"><span class="cl">Node size:          <span class="m">16384</span>
</span></span><span class="line"><span class="cl">Sector size:        <span class="m">4096</span>
</span></span><span class="line"><span class="cl">Filesystem size:    55.00GiB
</span></span><span class="line"><span class="cl">Block group profiles:
</span></span><span class="line"><span class="cl">  Data:             single            1.00GiB
</span></span><span class="line"><span class="cl">  Metadata:         DUP               1.00GiB
</span></span><span class="line"><span class="cl">  System:           DUP               8.00MiB
</span></span><span class="line"><span class="cl">SSD detected:       no
</span></span><span class="line"><span class="cl">Zoned device:       no
</span></span><span class="line"><span class="cl">Incompat features:  extref, skinny-metadata
</span></span><span class="line"><span class="cl">Runtime features:   
</span></span><span class="line"><span class="cl">Checksum:           crc32c
</span></span><span class="line"><span class="cl">Number of devices:  <span class="m">1</span>
</span></span><span class="line"><span class="cl">Devices:
</span></span><span class="line"><span class="cl">   ID        SIZE  PATH
</span></span><span class="line"><span class="cl">    <span class="m">1</span>    55.00GiB  /storage/btrfs.disk
</span></span></code></pre></td></tr></table>
</div>
</div><p>If your filesystem reports a different data block group as being of 8M, it&rsquo;s
because of this
<a href="https://lore.kernel.org/linux-btrfs/c830b01e-08c5-c2fb-c322-3f216f53dd8e@suse.com/T/#m26bc34876cc090eca0e2271dc7c9733874b50023">issue</a>
that was reported, but maybe not yet fixed. It&rsquo;s important to understand that
these numbers reflect the allocation strategy for <em>single profile</em>. For raid
setups, these numbers can be different.</p>
<p>Also, the block group sizes doesn&rsquo;t affect the number of maximum number of
inodes that can be created, as we&rsquo;ll see later.</p>
<p>We can inspect the block groups by using the <strong>btrfs</strong> tool:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">$ btrfs inspect-internal dump-tree -t extent /storage/btrfs.disk <span class="p">|</span> grep -A1 BLOCK_GROUP
</span></span><span class="line"><span class="cl">        item <span class="m">0</span> key <span class="o">(</span><span class="m">1078984704</span> BLOCK_GROUP_ITEM 1073741824<span class="o">)</span> itemoff <span class="m">16259</span> itemsize <span class="m">24</span>
</span></span><span class="line"><span class="cl">                block group used <span class="m">0</span> chunk_objectid <span class="m">256</span> flags DATA
</span></span><span class="line"><span class="cl">        item <span class="m">1</span> key <span class="o">(</span><span class="m">2152726528</span> BLOCK_GROUP_ITEM 8388608<span class="o">)</span> itemoff <span class="m">16235</span> itemsize <span class="m">24</span>
</span></span><span class="line"><span class="cl">                block group used <span class="m">16384</span> chunk_objectid <span class="m">256</span> flags SYSTEM<span class="p">|</span>DUP
</span></span><span class="line"><span class="cl">...
</span></span><span class="line"><span class="cl">        item <span class="m">4</span> key <span class="o">(</span><span class="m">2161115136</span> BLOCK_GROUP_ITEM 1073741824<span class="o">)</span> itemoff <span class="m">16145</span> itemsize <span class="m">24</span>
</span></span><span class="line"><span class="cl">                block group used <span class="m">114688</span> chunk_objectid <span class="m">256</span> flags METADATA<span class="p">|</span>DUP
</span></span></code></pre></td></tr></table>
</div>
</div><p>The above command used the <em>inspect-internal</em> subcommand to dump the entire
<em>extent-tree</em>. We can compare the block group sizes (the numbers after the
<em>BLOCK_GROUP_ITEM</em>) in bytes that match we the previous mkfs.btrfs output. The
profiles are also dumped and can be verified, being DUP for <em>system</em> and
<em>metadata</em>.</p>
<p>When we write more files, or if a file occupies more than 1G of data, more data
block groups are created (the <em>flags</em> field shows the type of the block group):</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl"><span class="c1"># Creating a 2.5G file</span>
</span></span><span class="line"><span class="cl">$ dd <span class="k">if</span><span class="o">=</span>/dev/urandom <span class="nv">of</span><span class="o">=</span>/mnt/testing/file.bin <span class="nv">bs</span><span class="o">=</span>1M <span class="nv">count</span><span class="o">=</span><span class="m">2500</span>
</span></span><span class="line"><span class="cl">$ sync
</span></span><span class="line"><span class="cl"><span class="c1"># Check the new data block groups</span>
</span></span><span class="line"><span class="cl">$ btrfs inspect-internal dump-tree -t extent /storage/btrfs.disk<span class="p">|</span> grep -A1 BLOCK_GROUP 
</span></span><span class="line"><span class="cl">        item <span class="m">0</span> key <span class="o">(</span><span class="m">1078984704</span> BLOCK_GROUP_ITEM 1073741824<span class="o">)</span> itemoff <span class="m">16259</span> itemsize <span class="m">24</span>
</span></span><span class="line"><span class="cl">                block group used <span class="m">940572672</span> chunk_objectid <span class="m">256</span> flags DATA
</span></span><span class="line"><span class="cl">..
</span></span><span class="line"><span class="cl">        item <span class="m">13</span> key <span class="o">(</span><span class="m">2152726528</span> BLOCK_GROUP_ITEM 8388608<span class="o">)</span> itemoff <span class="m">15619</span> itemsize <span class="m">24</span>
</span></span><span class="line"><span class="cl">                block group used <span class="m">16384</span> chunk_objectid <span class="m">256</span> flags SYSTEM<span class="p">|</span>DUP
</span></span><span class="line"><span class="cl">        item <span class="m">14</span> key <span class="o">(</span><span class="m">2161115136</span> BLOCK_GROUP_ITEM 1073741824<span class="o">)</span> itemoff <span class="m">15595</span> itemsize <span class="m">24</span>
</span></span><span class="line"><span class="cl">                block group used <span class="m">2899968</span> chunk_objectid <span class="m">256</span> flags METADATA<span class="p">|</span>DUP
</span></span><span class="line"><span class="cl">..
</span></span><span class="line"><span class="cl">        item <span class="m">192</span> key <span class="o">(</span><span class="m">3234856960</span> BLOCK_GROUP_ITEM 1073741824<span class="o">)</span> itemoff <span class="m">9730</span> itemsize <span class="m">24</span>
</span></span><span class="line"><span class="cl">                block group used <span class="m">939524096</span> chunk_objectid <span class="m">256</span> flags DATA
</span></span><span class="line"><span class="cl">..
</span></span><span class="line"><span class="cl">        item <span class="m">201</span> key <span class="o">(</span><span class="m">4308598784</span> BLOCK_GROUP_ITEM 1073741824<span class="o">)</span> itemoff <span class="m">9282</span> itemsize <span class="m">24</span>
</span></span><span class="line"><span class="cl">                block group used <span class="m">742391808</span> chunk_objectid <span class="m">256</span> flags DATA
</span></span></code></pre></td></tr></table>
</div>
</div><p>We can see that new data block groups were created. If we remove the file, the
used space is updated to reflect the file removal:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">$ rm /mnt/testing/file.bin
</span></span><span class="line"><span class="cl">$ sync
</span></span><span class="line"><span class="cl">$ btrfs inspect-internal dump-tree -t extent /storage/btrfs.disk<span class="p">|</span> grep -A1 BLOCK_GROUP
</span></span><span class="line"><span class="cl">        item <span class="m">1</span> key <span class="o">(</span><span class="m">1078984704</span> BLOCK_GROUP_ITEM 1073741824<span class="o">)</span> itemoff <span class="m">16206</span> itemsize <span class="m">24</span>
</span></span><span class="line"><span class="cl">                block group used <span class="m">1048576</span> chunk_objectid <span class="m">256</span> flags DATA
</span></span><span class="line"><span class="cl">..
</span></span><span class="line"><span class="cl">        item <span class="m">6</span> key <span class="o">(</span><span class="m">2152726528</span> BLOCK_GROUP_ITEM 8388608<span class="o">)</span> itemoff <span class="m">15990</span> itemsize <span class="m">24</span>
</span></span><span class="line"><span class="cl">                block group used <span class="m">16384</span> chunk_objectid <span class="m">256</span> flags SYSTEM<span class="p">|</span>DUP
</span></span><span class="line"><span class="cl">        item <span class="m">7</span> key <span class="o">(</span><span class="m">2161115136</span> BLOCK_GROUP_ITEM 1073741824<span class="o">)</span> itemoff <span class="m">15966</span> itemsize <span class="m">24</span>
</span></span><span class="line"><span class="cl">                block group used <span class="m">147456</span> chunk_objectid <span class="m">256</span> flags METADATA<span class="p">|</span>DUP
</span></span><span class="line"><span class="cl">..
</span></span><span class="line"><span class="cl">        item <span class="m">17</span> key <span class="o">(</span><span class="m">3234856960</span> BLOCK_GROUP_ITEM 1073741824<span class="o">)</span> itemoff <span class="m">15645</span> itemsize <span class="m">24</span>
</span></span><span class="line"><span class="cl">                block group used <span class="m">0</span> chunk_objectid <span class="m">256</span> flags DATA
</span></span><span class="line"><span class="cl">        item <span class="m">18</span> key <span class="o">(</span><span class="m">4308598784</span> BLOCK_GROUP_ITEM 1073741824<span class="o">)</span> itemoff <span class="m">15621</span> itemsize <span class="m">24</span>
</span></span><span class="line"><span class="cl">                block group used <span class="m">0</span> chunk_objectid <span class="m">256</span> flags DATA
</span></span></code></pre></td></tr></table>
</div>
</div><p>Take a look in the <em>block group use</em> field, they are now zeroed. The block
groups are still allocated, but a balance can remove the non used ones:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">$ btrfs balance start -dusage<span class="o">=</span><span class="m">0</span> /mnt/testing
</span></span><span class="line"><span class="cl">Done, had to relocate <span class="m">0</span> out of <span class="m">3</span> chunks
</span></span><span class="line"><span class="cl">$ btrfs inspect-internal dump-tree -textent /storage/btrfs.disk <span class="p">|</span> grep -A <span class="m">1</span> BLOCK_GROUP 
</span></span><span class="line"><span class="cl">        item <span class="m">0</span> key <span class="o">(</span><span class="m">1078984704</span> BLOCK_GROUP_ITEM 1073741824<span class="o">)</span> itemoff <span class="m">16259</span> itemsize <span class="m">24</span>
</span></span><span class="line"><span class="cl">                block group used <span class="m">524288</span> chunk_objectid <span class="m">256</span> flags DATA
</span></span><span class="line"><span class="cl">..
</span></span><span class="line"><span class="cl">        item <span class="m">3</span> key <span class="o">(</span><span class="m">2152726528</span> BLOCK_GROUP_ITEM 8388608<span class="o">)</span> itemoff <span class="m">16129</span> itemsize <span class="m">24</span>
</span></span><span class="line"><span class="cl">                block group used <span class="m">16384</span> chunk_objectid <span class="m">256</span> flags SYSTEM<span class="p">|</span>DUP
</span></span><span class="line"><span class="cl">..
</span></span><span class="line"><span class="cl">        item <span class="m">5</span> key <span class="o">(</span><span class="m">2161115136</span> BLOCK_GROUP_ITEM 1073741824<span class="o">)</span> itemoff <span class="m">16072</span> itemsize <span class="m">24</span>
</span></span><span class="line"><span class="cl">                block group used <span class="m">147456</span> chunk_objectid <span class="m">256</span> flags METADATA<span class="p">|</span>DUP
</span></span></code></pre></td></tr></table>
</div>
</div><p>It shows only one data block group.</p>
<h2 id="btrfs-inodes">Btrfs: inodes<a hidden class="anchor" aria-hidden="true" href="#btrfs-inodes">#</a></h2>
<p>Btrfs does not use fixes inode bitmaps for inode allocation. As stated before,
btrfs allocates internal <strong>items</strong> to manage its metadata. Each item is
addressed by three values that together compose a <strong>key</strong>. These values are
described as <strong>objectid</strong>, <strong>type</strong> and <strong>offset</strong>.</p>
<p>This is the fs tree right after the filesystem is created:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">$ btrfs inspect-internal dump-tree -t fs /storage/btrfs.disk
</span></span><span class="line"><span class="cl">btrfs-progs v5.16.1 
</span></span><span class="line"><span class="cl">fs tree key <span class="o">(</span>FS_TREE ROOT_ITEM 0<span class="o">)</span> 
</span></span><span class="line"><span class="cl">leaf <span class="m">30474240</span> items <span class="m">2</span> free space <span class="m">16061</span> generation <span class="m">5</span> owner FS_TREE
</span></span><span class="line"><span class="cl">leaf <span class="m">30474240</span> flags 0x1<span class="o">(</span>WRITTEN<span class="o">)</span> backref revision <span class="m">1</span>
</span></span><span class="line"><span class="cl">fs uuid b62385e4-e0cc-497f-a220-29ae6465510d
</span></span><span class="line"><span class="cl">chunk uuid b3e0fa4d-fddb-40b3-bd9c-349df8095b39
</span></span><span class="line"><span class="cl">        item <span class="m">0</span> key <span class="o">(</span><span class="m">256</span> INODE_ITEM 0<span class="o">)</span> itemoff <span class="m">16123</span> itemsize <span class="m">160</span>
</span></span><span class="line"><span class="cl">                generation <span class="m">3</span> transid <span class="m">0</span> size <span class="m">0</span> nbytes <span class="m">16384</span>
</span></span><span class="line"><span class="cl">                block group <span class="m">0</span> mode <span class="m">40755</span> links <span class="m">1</span> uid <span class="m">0</span> gid <span class="m">0</span> rdev <span class="m">0</span>
</span></span><span class="line"><span class="cl">                sequence <span class="m">0</span> flags 0x0<span class="o">(</span>none<span class="o">)</span>
</span></span><span class="line"><span class="cl">                atime 1650811378.0 <span class="o">(</span>2022-04-24 11:42:58<span class="o">)</span>
</span></span><span class="line"><span class="cl">                ctime 1650811378.0 <span class="o">(</span>2022-04-24 11:42:58<span class="o">)</span>
</span></span><span class="line"><span class="cl">                mtime 1650811378.0 <span class="o">(</span>2022-04-24 11:42:58<span class="o">)</span>
</span></span><span class="line"><span class="cl">                otime 1650811378.0 <span class="o">(</span>2022-04-24 11:42:58<span class="o">)</span>
</span></span><span class="line"><span class="cl">        item <span class="m">1</span> key <span class="o">(</span><span class="m">256</span> INODE_REF 256<span class="o">)</span> itemoff <span class="m">16111</span> itemsize <span class="m">12</span>
</span></span><span class="line"><span class="cl">                index <span class="m">0</span> namelen <span class="m">2</span> name: ..
</span></span></code></pre></td></tr></table>
</div>
</div><p>There are two items in the listing, and the two refer to the top level
directory. The INODE_ITEM item contains data about the inode, owner, size and
etc. Its key is always (inode_number INODE_ITEM 0), and 256 is the first inode
number used in a filesystem tree.</p>
<p>The INODE_REF item maps an inode to its parent directory (inode_number
INODE_REF parent_dir_inode). In this case it points to itself since the top
level directory ancestor is itself.</p>
<p>By creating a file, we can see more structures being allocated:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">$ touch /mnt/testing/file.txt
</span></span><span class="line"><span class="cl">$ sync
</span></span><span class="line"><span class="cl">$ btrfs inspect-internal dump-tree -t fs /storage/btrfs.disk
</span></span><span class="line"><span class="cl">...
</span></span><span class="line"><span class="cl">        item <span class="m">2</span> key <span class="o">(</span><span class="m">256</span> DIR_ITEM 3956591618<span class="o">)</span> itemoff <span class="m">16073</span> itemsize <span class="m">38</span>
</span></span><span class="line"><span class="cl">                location key <span class="o">(</span><span class="m">257</span> INODE_ITEM 0<span class="o">)</span> <span class="nb">type</span> FILE
</span></span><span class="line"><span class="cl">                transid <span class="m">9</span> data_len <span class="m">0</span> name_len <span class="m">8</span>
</span></span><span class="line"><span class="cl">                name: file.txt
</span></span><span class="line"><span class="cl">        item <span class="m">3</span> key <span class="o">(</span><span class="m">256</span> DIR_INDEX 2<span class="o">)</span> itemoff <span class="m">16035</span> itemsize <span class="m">38</span>
</span></span><span class="line"><span class="cl">                location key <span class="o">(</span><span class="m">257</span> INODE_ITEM 0<span class="o">)</span> <span class="nb">type</span> FILE
</span></span><span class="line"><span class="cl">                transid <span class="m">9</span> data_len <span class="m">0</span> name_len <span class="m">8</span>
</span></span><span class="line"><span class="cl">                name: file.txt
</span></span><span class="line"><span class="cl">        item <span class="m">4</span> key <span class="o">(</span><span class="m">257</span> INODE_ITEM 0<span class="o">)</span> itemoff <span class="m">15875</span> itemsize <span class="m">160</span>
</span></span><span class="line"><span class="cl">                generation <span class="m">9</span> transid <span class="m">9</span> size <span class="m">0</span> nbytes <span class="m">0</span>
</span></span><span class="line"><span class="cl">                block group <span class="m">0</span> mode <span class="m">100644</span> links <span class="m">1</span> uid <span class="m">0</span> gid <span class="m">0</span> rdev <span class="m">0</span>
</span></span><span class="line"><span class="cl">                sequence <span class="m">10</span> flags 0x0<span class="o">(</span>none<span class="o">)</span>
</span></span><span class="line"><span class="cl">                atime 1650811865.463886516 <span class="o">(</span>2022-04-24 11:51:05<span class="o">)</span>
</span></span><span class="line"><span class="cl">                ctime 1650811865.463886516 <span class="o">(</span>2022-04-24 11:51:05<span class="o">)</span>
</span></span><span class="line"><span class="cl">                mtime 1650811865.463886516 <span class="o">(</span>2022-04-24 11:51:05<span class="o">)</span>
</span></span><span class="line"><span class="cl">                otime 1650811865.463886516 <span class="o">(</span>2022-04-24 11:51:05<span class="o">)</span>
</span></span><span class="line"><span class="cl">        item <span class="m">5</span> key <span class="o">(</span><span class="m">257</span> INODE_REF 256<span class="o">)</span> itemoff <span class="m">15857</span> itemsize <span class="m">18</span>
</span></span><span class="line"><span class="cl">                index <span class="m">2</span> namelen <span class="m">8</span> name: file.txt
</span></span></code></pre></td></tr></table>
</div>
</div><p>A new INODE_ITEM was allocated for file.txt, using the inode number 257. The
new INODE_REF item&rsquo;s <strong>offset</strong> points to 256, which is the top level directory,
as expected.</p>
<p>Two new items are also allocated: DIR_ITEM and DIR_INDEX. DIR_INDEX is used for
directory listing, like readdir for example. Its key (parent_dir_inode
DIR_INDEX pos) almost explains itself. The <strong>pos</strong> value says it&rsquo;s the third
file created in the directory, as values 1 and 2 are related to &lsquo;.&rsquo; and &lsquo;..&rsquo;
respectively. DIR_ITEM is used for searching. Its <strong>offset</strong> value is the
filename hashed, making it quick to find a file by name inside a directory.</p>
<p>As the file grows, more item are created:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">$ dd <span class="k">if</span><span class="o">=</span>/dev/urandom <span class="nv">of</span><span class="o">=</span>/mnt/testing/file.txt <span class="nv">bs</span><span class="o">=</span>1M <span class="nv">count</span><span class="o">=</span><span class="m">500</span>
</span></span><span class="line"><span class="cl">$ sync
</span></span><span class="line"><span class="cl">$ btrfs inspect-internal dump-tree -t fs btrfs.disk
</span></span><span class="line"><span class="cl">...
</span></span><span class="line"><span class="cl">        item <span class="m">6</span> key <span class="o">(</span><span class="m">257</span> EXTENT_DATA 0<span class="o">)</span> itemoff <span class="m">15804</span> itemsize <span class="m">53</span>
</span></span><span class="line"><span class="cl">                generation <span class="m">12</span> <span class="nb">type</span> <span class="m">1</span> <span class="o">(</span>regular<span class="o">)</span>
</span></span><span class="line"><span class="cl">                extent data disk byte <span class="m">1104150528</span> nr <span class="m">134217728</span>
</span></span><span class="line"><span class="cl">                extent data offset <span class="m">0</span> nr <span class="m">134217728</span> ram <span class="m">134217728</span>
</span></span><span class="line"><span class="cl">                extent compression <span class="m">0</span> <span class="o">(</span>none<span class="o">)</span>
</span></span><span class="line"><span class="cl">        item <span class="m">7</span> key <span class="o">(</span><span class="m">257</span> EXTENT_DATA 134217728<span class="o">)</span> itemoff <span class="m">15751</span> itemsize <span class="m">53</span>
</span></span><span class="line"><span class="cl">                generation <span class="m">12</span> <span class="nb">type</span> <span class="m">1</span> <span class="o">(</span>regular<span class="o">)</span>
</span></span><span class="line"><span class="cl">                extent data disk byte <span class="m">1238368256</span> nr <span class="m">134217728</span>
</span></span><span class="line"><span class="cl">                extent data offset <span class="m">0</span> nr <span class="m">134217728</span> ram <span class="m">134217728</span>
</span></span><span class="line"><span class="cl">                extent compression <span class="m">0</span> <span class="o">(</span>none<span class="o">)</span>
</span></span><span class="line"><span class="cl">        item <span class="m">8</span> key <span class="o">(</span><span class="m">257</span> EXTENT_DATA 268435456<span class="o">)</span> itemoff <span class="m">15698</span> itemsize <span class="m">53</span>
</span></span><span class="line"><span class="cl">                generation <span class="m">12</span> <span class="nb">type</span> <span class="m">1</span> <span class="o">(</span>regular<span class="o">)</span>
</span></span><span class="line"><span class="cl">                extent data disk byte <span class="m">1372585984</span> nr <span class="m">134217728</span>
</span></span><span class="line"><span class="cl">                extent data offset <span class="m">0</span> nr <span class="m">134217728</span> ram <span class="m">134217728</span>
</span></span><span class="line"><span class="cl">                extent compression <span class="m">0</span> <span class="o">(</span>none<span class="o">)</span>
</span></span><span class="line"><span class="cl">        item <span class="m">9</span> key <span class="o">(</span><span class="m">257</span> EXTENT_DATA 402653184<span class="o">)</span> itemoff <span class="m">15645</span> itemsize <span class="m">53</span>
</span></span><span class="line"><span class="cl">                generation <span class="m">12</span> <span class="nb">type</span> <span class="m">1</span> <span class="o">(</span>regular<span class="o">)</span>
</span></span><span class="line"><span class="cl">                extent data disk byte <span class="m">1506803712</span> nr <span class="m">90177536</span>
</span></span><span class="line"><span class="cl">                extent data offset <span class="m">0</span> nr <span class="m">90177536</span> ram <span class="m">90177536</span>
</span></span><span class="line"><span class="cl">                extent compression <span class="m">0</span> <span class="o">(</span>none<span class="o">)</span>
</span></span><span class="line"><span class="cl">        item <span class="m">10</span> key <span class="o">(</span><span class="m">257</span> EXTENT_DATA 492830720<span class="o">)</span> itemoff <span class="m">15592</span> itemsize <span class="m">53</span>
</span></span><span class="line"><span class="cl">                generation <span class="m">12</span> <span class="nb">type</span> <span class="m">1</span> <span class="o">(</span>regular<span class="o">)</span>
</span></span><span class="line"><span class="cl">                extent data disk byte <span class="m">1596981248</span> nr <span class="m">1048576</span>
</span></span><span class="line"><span class="cl">                extent data offset <span class="m">0</span> nr <span class="m">1048576</span> ram <span class="m">1048576</span>
</span></span><span class="line"><span class="cl">                extent compression <span class="m">0</span> <span class="o">(</span>none<span class="o">)</span>
</span></span><span class="line"><span class="cl">        item <span class="m">11</span> key <span class="o">(</span><span class="m">257</span> EXTENT_DATA 493879296<span class="o">)</span> itemoff <span class="m">15539</span> itemsize <span class="m">53</span>
</span></span><span class="line"><span class="cl">                generation <span class="m">12</span> <span class="nb">type</span> <span class="m">1</span> <span class="o">(</span>regular<span class="o">)</span>
</span></span><span class="line"><span class="cl">                extent data disk byte <span class="m">1598029824</span> nr <span class="m">30408704</span>
</span></span><span class="line"><span class="cl">                extent data offset <span class="m">0</span> nr <span class="m">30408704</span> ram <span class="m">30408704</span>
</span></span><span class="line"><span class="cl">                extent compression <span class="m">0</span> <span class="o">(</span>none<span class="o">)</span>
</span></span><span class="line"><span class="cl">...
</span></span></code></pre></td></tr></table>
</div>
</div><p>New EXTENT_DATA items are created to manage the data related to user files. The
<strong>objectid</strong> of the EXTENT_DATA&rsquo;s key informs to which inode the data is
associated.</p>
<p>More data about btrfs item can be found <a href="https://github.com/btrfs/btrfs-dev-docs/blob/master/tree-items.txt">in this
document</a>.</p>
<h2 id="why-cant-btrfs-show-how-many-inodes-it-can-hold"><em>Why can&rsquo;t btrfs show how many inodes it can hold?</em><a hidden class="anchor" aria-hidden="true" href="#why-cant-btrfs-show-how-many-inodes-it-can-hold">#</a></h2>
<p>Because it&rsquo;s impossible to known beforehand.</p>
<p>The same metadata block group space is used to store INODE_ITEM, EXTENT_DATA and
all other metadata items. So if a workload creates bigger files, it ends ups
creating more EXTENT_DATA items, which can end up consuming a huge number of
metadata block groups to manage extents.</p>
<p>On the other hand, if your workload ends up creating a huge number of small
files, it would end up creating less EXTENT_DATA items, making it possible to
store different items, including INODE_ITEMs, making it possible to create more
files.</p>
<p>That&rsquo;s the reason for the number of inodes cannot be checked by using df. The
df tool uses the <a href="https://man7.org/linux/man-pages/man2/statfs.2.html">statfs</a>
system call to show the information about inodes. The system call populates the
statfs struct with the values related to the filesystem being checked, and the
f_files field contains the maximum number of inodes.</p>
<p>By looking at the kernel code, the function
<a href="https://elixir.bootlin.com/linux/latest/source/fs/btrfs/super.c#L2256"><em>btrfs_statfs</em></a>
does not set buf-&gt;f_files, while in
<a href="https://elixir.bootlin.com/linux/latest/source/fs/ext4/super.c#L6228"><em>ext4_statfs</em></a>
we can see the information being get from the superblock.</p>
<h1 id="btrfs-inodes-and-subvolumes">Btrfs: Inodes and subvolumes<a hidden class="anchor" aria-hidden="true" href="#btrfs-inodes-and-subvolumes">#</a></h1>
<p>In btrfs, subvolumes store user data, and act like different filesystems, as
each subvolume can be mounted separately. It can be compared to a disk
partition, but having much more features, like creating snapshots. openSUSE and
SUSE Linux Enterprise (SLE) uses subvolumes to divide the filesystem into logic
structures, and also to manage snapshots after each upgrade:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">$ btrfs subvolume list /
</span></span><span class="line"><span class="cl"><span class="o">[</span>sudo<span class="o">]</span> password <span class="k">for</span> root: 
</span></span><span class="line"><span class="cl">ID <span class="m">256</span> gen <span class="m">31</span> top level <span class="m">5</span> path @
</span></span><span class="line"><span class="cl">ID <span class="m">257</span> gen <span class="m">161195</span> top level <span class="m">256</span> path @/var
</span></span><span class="line"><span class="cl">ID <span class="m">258</span> gen <span class="m">161097</span> top level <span class="m">256</span> path @/usr/local
</span></span><span class="line"><span class="cl">ID <span class="m">259</span> gen <span class="m">64676</span> top level <span class="m">256</span> path @/srv
</span></span><span class="line"><span class="cl">ID <span class="m">260</span> gen <span class="m">149398</span> top level <span class="m">256</span> path @/root
</span></span><span class="line"><span class="cl">ID <span class="m">261</span> gen <span class="m">146119</span> top level <span class="m">256</span> path @/opt
</span></span><span class="line"><span class="cl">ID <span class="m">262</span> gen <span class="m">161195</span> top level <span class="m">256</span> path @/home
</span></span><span class="line"><span class="cl">ID <span class="m">263</span> gen <span class="m">150062</span> top level <span class="m">256</span> path @/boot/grub2/x86_64-efi
</span></span><span class="line"><span class="cl">ID <span class="m">264</span> gen <span class="m">27</span> top level <span class="m">256</span> path @/boot/grub2/i386-pc
</span></span><span class="line"><span class="cl">ID <span class="m">265</span> gen <span class="m">160386</span> top level <span class="m">256</span> path @/.snapshots
</span></span><span class="line"><span class="cl">ID <span class="m">266</span> gen <span class="m">161162</span> top level <span class="m">265</span> path @/.snapshots/1/snapshot
</span></span><span class="line"><span class="cl">ID <span class="m">342</span> gen <span class="m">110017</span> top level <span class="m">265</span> path @/.snapshots/77/snapshot
</span></span><span class="line"><span class="cl">ID <span class="m">343</span> gen <span class="m">110254</span> top level <span class="m">265</span> path @/.snapshots/78/snapshot
</span></span><span class="line"><span class="cl">ID <span class="m">346</span> gen <span class="m">112147</span> top level <span class="m">265</span> path @/.snapshots/81/snapshot
</span></span><span class="line"><span class="cl">ID <span class="m">347</span> gen <span class="m">112149</span> top level <span class="m">265</span> path @/.snapshots/82/snapshot
</span></span><span class="line"><span class="cl">ID <span class="m">352</span> gen <span class="m">113071</span> top level <span class="m">265</span> path @/.snapshots/87/snapshot
</span></span><span class="line"><span class="cl">ID <span class="m">353</span> gen <span class="m">113100</span> top level <span class="m">257</span> path @/var/lib/machines
</span></span><span class="line"><span class="cl">...
</span></span></code></pre></td></tr></table>
</div>
</div><p>An interesting fact about subvolumes is that files always start from inode 257,
and the same inode numbers are used in different subvolumes. Since each
subvolume is a different tree inside btrfs, it&rsquo;s not a problem for the end
user. Let&rsquo;s see an example of this happening:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">$ mount /storage/btrfs.disk /mnt/testing
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$ btrfs subvolume create /mnt/testing/vol1
</span></span><span class="line"><span class="cl">Create subvolume <span class="s1">&#39;/mnt/testing/vol1&#39;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$ btrfs subvolume create /mnt/testing/vol2
</span></span><span class="line"><span class="cl">Create subvolume <span class="s1">&#39;/mnt/testing/vol2&#39;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># let&#39;s create directories and files inside each subvolume</span>
</span></span><span class="line"><span class="cl">$ touch /mnt/testing/vol1/file1
</span></span><span class="line"><span class="cl">$ touch /mnt/testing/vol1/file2
</span></span><span class="line"><span class="cl">$ mkdir /mnt/testing/vol2/dir1
</span></span><span class="line"><span class="cl">$ touch /mnt/testing/vol2/filexx
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># let&#39;s list the inodes of there files/direcotry</span>
</span></span><span class="line"><span class="cl">$ ls -iR /mnt/testing
</span></span><span class="line"><span class="cl">/mnt/testing:
</span></span><span class="line"><span class="cl"><span class="m">256</span> vol1  <span class="m">256</span> vol2
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">/mnt/testing/vol1:
</span></span><span class="line"><span class="cl"><span class="m">257</span> file1  <span class="m">258</span> file2
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">/mnt/testing/vol2:
</span></span><span class="line"><span class="cl"><span class="m">257</span> dir1  <span class="m">258</span> filexx
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">/mnt/testing/vol2/dir1:
</span></span></code></pre></td></tr></table>
</div>
</div><p>From the output above we can see that both <em>file1</em> and <em>dir</em>, and <em>file2</em> and
<em>filexx</em> have the same inode numbers.</p>
<h2 id="considerations">Considerations<a hidden class="anchor" aria-hidden="true" href="#considerations">#</a></h2>
<p>Interested readers may want to take a look into the
<a href="https://www.kernel.org/doc/html/latest/filesystems/ext4/overview.html">ext4 kernel documentation</a>
, the <a href="https://man7.org/linux/man-pages/man8/mke2fs.8.html">mke2fs documentation</a>
and the <a href="https://man7.org/linux/man-pages/man5/mke2fs.conf.5.html">configuration file</a>
used by mke2fs for the default filesystem settings.</p>
<p>Btrfs has a nice <a href="https://btrfs.wiki.kernel.org/index.php/Main_Page">wiki page</a>
detailing how things work. Additional info can be get from the mkfs.btrfs
utility <a href="https://btrfs.wiki.kernel.org/index.php/Manpage/mkfs.btrfs">man page</a>
and for the more curious readers, the
<a href="https://github.com/btrfs/btrfs-dev-docs/">btrfs-dev-docs</a> details the inner
parts of the filesystem.</p>
<p>The post got much bigger than I expected. The initial focus was to only mention
about the kernel code setting the number of inodes in ex4, and the math involved
to find the maximum number of inodes. While talking with some friends, it became
more evident that more background would be more interesting. So that explains
why block groups, subvolumes and everything in between was mentioned.</p>
<p>Thanks for reading!</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
<nav class="paginav">
  <a class="prev" href="https://mpdesouza.com/blog/from-zero-to-double-free/">
    <span class="title">« Prev Page</span>
    <br>
    <span>From zero to double free: The process of creating a reproducer for a kernel vulnerability</span>
  </a>
  <a class="next" href="https://mpdesouza.com/blog/btrfs-resolving-the-logical-resolve/">
    <span class="title">Next Page »</span>
    <br>
    <span>Btrfs: Resolving the logical-resolve</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="https://mpdesouza.com">Marcos&#39; Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerText = 'copy';

        function copyingDone() {
            copybutton.innerText = 'copied!';
            setTimeout(() => {
                copybutton.innerText = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
