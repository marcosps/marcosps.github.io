<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Kernel Adventures: Enabling VPD Pages for USB Storage Devices in sysfs | Marcos&#39; Blog</title>
<meta name="keywords" content="">
<meta name="description" content="Sample article showcasing basic Markdown syntax and formatting for HTML elements.">
<meta name="author" content="Marcos Paulo de Souza">
<link rel="canonical" href="https://mpdesouza.com/blog/kernel-adventures-enabling-vpd-pages-for-usb-storage-devices-in-sysfs/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.3613efbd0b1772781e8f49935e973cae632a7f61471c05b17be155505ccf87b5.css" integrity="sha256-NhPvvQsXcngej0mTXpc8rmMqf2FHHAWxe&#43;FVUFzPh7U=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://mpdesouza.com/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://mpdesouza.com/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://mpdesouza.com/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://mpdesouza.com/apple-touch-icon.png">
<link rel="mask-icon" href="https://mpdesouza.com/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-LWD0KKCW2G"></script>
<script>
var doNotTrack = false;
if (!doNotTrack) {
	window.dataLayer = window.dataLayer || [];
	function gtag(){dataLayer.push(arguments);}
	gtag('js', new Date());
	gtag('config', 'G-LWD0KKCW2G', { 'anonymize_ip': false });
}
</script>
<meta property="og:title" content="Kernel Adventures: Enabling VPD Pages for USB Storage Devices in sysfs" />
<meta property="og:description" content="Sample article showcasing basic Markdown syntax and formatting for HTML elements." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://mpdesouza.com/blog/kernel-adventures-enabling-vpd-pages-for-usb-storage-devices-in-sysfs/" /><meta property="article:section" content="blog" />
<meta property="article:published_time" content="2019-08-16T00:00:00+00:00" />
<meta property="article:modified_time" content="2019-08-16T00:00:00+00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Kernel Adventures: Enabling VPD Pages for USB Storage Devices in sysfs"/>
<meta name="twitter:description" content="Sample article showcasing basic Markdown syntax and formatting for HTML elements."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Blog",
      "item": "https://mpdesouza.com/blog/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "Kernel Adventures: Enabling VPD Pages for USB Storage Devices in sysfs",
      "item": "https://mpdesouza.com/blog/kernel-adventures-enabling-vpd-pages-for-usb-storage-devices-in-sysfs/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Kernel Adventures: Enabling VPD Pages for USB Storage Devices in sysfs",
  "name": "Kernel Adventures: Enabling VPD Pages for USB Storage Devices in sysfs",
  "description": "Sample article showcasing basic Markdown syntax and formatting for HTML elements.",
  "keywords": [
    
  ],
  "articleBody": "After chasing the problem of rotational sysfs property of USB flash drives, I started to check another sysfs attributes of USB storage devices, and I noted two missing attributes: vpd_pg80 and vpd_pg83.\nAs explained here, VPD pages contain data related to the device. In special, page 80 is Unit Serial Number (sn) and page 83 is Device Information (di), which are present in any SCSI device that complies with SPC-2 or later.\nCheck an example of my sn and di of my SSD using sg_vpd from sg3_utils package:\n1 2 3 4 5 6 7 8 9 10 11 $ sg_vpd --page 0x80 /dev/sda Unit serial number VPD page: Unit serial number: FS71N654610101U37 $ sg_vpd --page 0x83 /dev/sda Device Identification VPD page: Addressed logical unit: designator type: vendor specific [0x0], code set: ASCII vendor specific: FS71N654610101U37 designator type: T10 vendor identification, code set: ASCII vendor id: ATA vendor specific: SK hynix SC300 SATA 512GB FS71N654610101U37 This information is exported as attributes of storage devices in sysfs, like my HDD and SSD devices below:\n1 2 3 4 5 $ ls /sys/block/sd[ab]/device/vpd* /sys/block/sda/device/vpd_pg80 /sys/block/sda/device/vpd_pg83 /sys/block/sdb/device/vpd_pg80 /sys/block/sdb/device/vpd_pg83 This is true for the majority of storage devices, but not for USB flash drives. Most USB storage devices don’t have these attributes in sysfs, even when sg_vpd clearly shows them, like below:\n1 2 3 4 5 6 7 8 9 10 11 $ sg_vpd --page 0x80 /dev/sdc Unit serial number VPD page: Unit serial number: 4C530001300722111594 $ sg_vpd --page 0x83 /dev/sdc Device Identification VPD page: Addressed logical unit: designator type: T10 vendor identification, code set: ASCII vendor id: SanDisk vendor specific: Cruzer Blade $ ls /sys/block/sdc/device/vpd* zsh: no matches found: /sys/block/sdc/device/vpd* I’ve tested a bunch of different USB flash devices and USB to SATA adapters in my previous post, and neither of them had vpd_pg80 and vpd_pg83 in sysfs, although all SanDisk Cruzer Blade devices tested expose these VPD pages (thanks to my friend Alexandre Vicenzi who also had a Cruzer Blades to test).\nIn order to understand the problem, I decided to look at the kernel code. By using grep, I found a couple of interesting files:\n1 2 3 4 $ git grep -l pg80 drivers/scsi/scsi.c drivers/scsi/scsi_sysfs.c include/scsi/scsi_device.h At first glance, scsi_sysfs.c seems the best place to start. This file describes the sysfs attributes of SCSI devices, like vpd_pg80 and how the values of this properly is presented. So far, no information from where it is assigned.\nFile scsi.c had some answers. Looking at function scsi_attach_vpd, we can clearly see where the SCSI layer checks for Device Information and Serial Number.\nBut, let’s look at the first function that scsi_attach_vpd calls:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 /** * scsi_device_supports_vpd - test if a device supports VPD pages * @sdev: the \u0026amp;struct scsi_device to test * * If the 'try_vpd_pages' flag is set it takes precedence. * Otherwise we will assume VPD pages are supported if the * SCSI level is at least SPC-3 and 'skip_vpd_pages' is not set. */ static inline int scsi_device_supports_vpd(struct scsi_device *sdev) { /* Attempt VPD inquiry if the device blacklist explicitly calls * for it. */ if (sdev-\u003etry_vpd_pages) return 1; /* * Although VPD inquiries can go to SCSI-2 type devices, * some USB ones crash on receiving them, and the pages * we currently ask for are mandatory for SPC-2 and beyond */ if (sdev-\u003escsi_level \u003e= SCSI_SPC_2 \u0026\u0026 !sdev-\u003eskip_vpd_pages) return 1; return 0; } By looking at this function we can presume that try_vpd_pages flag is not set and skip_vpd_pages is. We can discard checking scsi_level because Cruzer Blade is SPC-4 compliant:\n1 2 3 $ sg_inq /dev/sdc | head -2 standard INQUIRY: PQual=0 Device_type=0 RMB=1 LU_CONG=0 version=0x06 [SPC-4] By looking at the comment of scsi_device_supports_vpd, some USB devices crash after checking their VPD pages, in this case, it makes sense to not enable VPD for all devices. Although, our SanDisk Cruzer Blade device clearly supports VPD and does not crash.\nscsi_device_supports_vpd is called in two places: scsi_add_lun and scsi_rescan_device. These callers are common path of device setup, so fixing skip_vpd_pages should be enough.\nLet’s grep again in the kernel source code to check where skip_vpd_pages is being set:\n1 2 3 4 5 $ git grep -l skip_vpd_pages drivers/scsi/scsi.c drivers/scsi/scsi_scan.c drivers/usb/storage/scsiglue.c include/scsi/scsi_device.h Interesting to see that USB layer setting this flag. Let’s check drivers/usb/stoarge/scsiglue.c file:\n1 2 /* Some devices don't handle VPD pages correctly */ sdev-\u003eskip_vpd_pages = 1; By the code above, which belongs to slave_configure function, USB layer disables VPD for all USB storage devices. Makes sense, since some devices are reported to crash when checking for VPD, as stated before.\nBut, shouldn’t we add support for SanDisk Cruzer Blade at least? There is a per device mapping with specific flags in SCSI layer that should help to fix this situation, specially regarding try_vpd_pages. To add support for SanDisk Cruzer Blade* devices, I submited this patch to the kernel mailing list and it’s now merged:\n1 2 3 4 5 {\"LENOVO\", \"Universal Xport\", \"*\", BLIST_NO_ULD_ATTACH}, + {\"SanDisk\", \"Cruzer Blade\", NULL, BLIST_TRY_VPD_PAGES | + BLIST_INQUIRY_36}, {\"SMSC\", \"USB 2 HS-CF\", NULL, BLIST_SPARSELUN | BLIST_INQUIRY_36}, ... The patch adds specific flags that will be checked in SCSI layer and will be applied once the SanDisk Cruzer Blade* device is found. This change alone does not fix the problem as the flag skip_vpd_pages is still enabled. So I submited a second patch, to only set skip_vpd_pages when try_vpd_pages is not set allowing the SCSI layer to process all VPD pages when try_vpd_pages is set.\n1 2 3 4 5 6 7 - /* Some devices don't handle VPD pages correctly */ - sdev-\u003eskip_vpd_pages = 1; + /* + * Some devices don't handle VPD pages correctly, so skip vpd + * pages if not forced by SCSI layer. + */ + sdev-\u003eskip_vpd_pages = !sdev-\u003etry_vpd_pages; With these two patches applied SanDisk Cruzer Blade USB flash device is able to properly show the VPD pages in sysfs:\n1 2 3 4 5 6 7 8 9 10 11 $ cat /sys/block/sda/device/vendor SanDisk $ cat /sys/block/sda/device/model Cruzer Blade $ cat /sys/block/sda/device/vpd_pg80 4C530001300722111594 $ cat /sys/block/sda/device/vpd_pg83 0,SanDiskCruzer Blade4C530001300722111594 That’s all for today. Stay tuned for more posts about Kernel and whatnot, see ya!\n",
  "wordCount" : "1052",
  "inLanguage": "en",
  "datePublished": "2019-08-16T00:00:00Z",
  "dateModified": "2019-08-16T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "Marcos Paulo de Souza"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://mpdesouza.com/blog/kernel-adventures-enabling-vpd-pages-for-usb-storage-devices-in-sysfs/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Marcos' Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://mpdesouza.com/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://mpdesouza.com" accesskey="h" title="Marcos&#39; Blog (Alt + H)">Marcos&#39; Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://mpdesouza.com/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="https://mpdesouza.com/about-me/" title="About Me">
                    <span>About Me</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://mpdesouza.com">Home</a>&nbsp;»&nbsp;<a href="https://mpdesouza.com/blog/">Blog</a></div>
    <h1 class="post-title">
      Kernel Adventures: Enabling VPD Pages for USB Storage Devices in sysfs
    </h1>
    <div class="post-description">
      Sample article showcasing basic Markdown syntax and formatting for HTML elements.
    </div>
    <div class="post-meta"><span title='2019-08-16 00:00:00 +0000 UTC'>August 16, 2019</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;Marcos Paulo de Souza

</div>
  </header> 

  <div class="post-content"><p>After chasing the problem of <a href="/kernel-adventures-are-usb-sticks-rotational-devices">rotational sysfs property of USB flash drives</a>, I started to check another <em>sysfs</em> attributes of USB storage devices, and I noted two missing attributes: <em>vpd_pg80</em> and <em>vpd_pg83</em>.</p>
<p>As explained <a href="/kernel-adventures-are-usb-sticks-rotational-devices">here</a>, VPD pages contain data related to the device. In special, page 80 is <em>Unit Serial Number</em> (sn) and page 83 is <em>Device Information</em> (di), which are present in any SCSI device that complies with <em>SPC-2</em> or later.</p>
<p>Check an example of my <em>sn</em> and <em>di</em> of my <em>SSD</em> using <strong>sg_vpd</strong> from sg3_utils package:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">$ sg_vpd --page 0x80 /dev/sda
</span></span><span class="line"><span class="cl">  Unit serial number VPD page:
</span></span><span class="line"><span class="cl">    Unit serial number: FS71N654610101U37
</span></span><span class="line"><span class="cl">$ sg_vpd --page 0x83 /dev/sda                                                                                        
</span></span><span class="line"><span class="cl">  Device Identification VPD page:
</span></span><span class="line"><span class="cl">    Addressed logical unit:
</span></span><span class="line"><span class="cl">      designator type: vendor specific <span class="o">[</span>0x0<span class="o">]</span>,  code set: ASCII
</span></span><span class="line"><span class="cl">        vendor specific: FS71N654610101U37   
</span></span><span class="line"><span class="cl">      designator type: T10 vendor identification,  code set: ASCII
</span></span><span class="line"><span class="cl">        vendor id: ATA     
</span></span><span class="line"><span class="cl">        vendor specific: SK hynix SC300 SATA 512GB               FS71N654610101U37
</span></span></code></pre></td></tr></table>
</div>
</div><p>This information is exported as attributes of storage devices in <em>sysfs</em>, like my HDD and SSD devices below:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">$ ls /sys/block/sd<span class="o">[</span>ab<span class="o">]</span>/device/vpd*
</span></span><span class="line"><span class="cl">  /sys/block/sda/device/vpd_pg80
</span></span><span class="line"><span class="cl">  /sys/block/sda/device/vpd_pg83
</span></span><span class="line"><span class="cl">  /sys/block/sdb/device/vpd_pg80
</span></span><span class="line"><span class="cl">  /sys/block/sdb/device/vpd_pg83
</span></span></code></pre></td></tr></table>
</div>
</div><p>This is true for the majority of storage devices, but not for USB flash drives. Most USB storage devices don’t have these attributes in <em>sysfs</em>, even when sg_vpd clearly shows them, like below:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">$ sg_vpd --page 0x80 /dev/sdc
</span></span><span class="line"><span class="cl">  Unit serial number VPD page:
</span></span><span class="line"><span class="cl">    Unit serial number: 4C530001300722111594
</span></span><span class="line"><span class="cl">$ sg_vpd --page 0x83 /dev/sdc
</span></span><span class="line"><span class="cl">  Device Identification VPD page:
</span></span><span class="line"><span class="cl">    Addressed logical unit:
</span></span><span class="line"><span class="cl">      designator type: T10 vendor identification,  code set: ASCII
</span></span><span class="line"><span class="cl">        vendor id: SanDisk
</span></span><span class="line"><span class="cl">        vendor specific: Cruzer Blade
</span></span><span class="line"><span class="cl">$ ls /sys/block/sdc/device/vpd*    
</span></span><span class="line"><span class="cl">  zsh: no matches found: /sys/block/sdc/device/vpd*
</span></span></code></pre></td></tr></table>
</div>
</div><p>I’ve tested a bunch of different USB flash devices and USB to SATA adapters <a href="/kernel-adventures-are-usb-sticks-rotational-devices">in my previous post</a>, and neither of them had <em>vpd_pg80</em> and <em>vpd_pg83</em> in <em>sysfs</em>, although all <em>SanDisk Cruzer Blade</em> devices tested expose these VPD pages (thanks to my friend <a href="https://twitter.com/alxvicenzi">Alexandre Vicenzi</a> who also had a <em>Cruzer Blades</em> to test).</p>
<p>In order to understand the problem, I decided to look at the kernel code. By using <em>grep</em>, I found a couple of interesting files:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">$ git grep -l pg80       
</span></span><span class="line"><span class="cl">drivers/scsi/scsi.c
</span></span><span class="line"><span class="cl">drivers/scsi/scsi_sysfs.c
</span></span><span class="line"><span class="cl">include/scsi/scsi_device.h
</span></span></code></pre></td></tr></table>
</div>
</div><p>At first glance, <em>scsi_sysfs.c</em> seems the best place to start. This file describes the <em>sysfs</em> attributes of SCSI devices, like <em>vpd_pg80</em> and how the values of this properly is presented. So far, no information from where it is assigned.</p>
<p>File <em>scsi.c</em> had some answers. Looking at function <em>scsi_attach_vpd</em>, we can clearly see where the SCSI layer checks for <em>Device Information</em> and <em>Serial Number</em>.</p>
<p>But, let’s look at the first function that <a href="https://elixir.bootlin.com/linux/v5.3-rc4/source/drivers/scsi/scsi.c#L454"><em>scsi_attach_vpd</em></a> calls:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * scsi_device_supports_vpd - test if a device supports VPD pages
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @sdev: the &amp;amp;struct scsi_device to test
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * If the &#39;try_vpd_pages&#39; flag is set it takes precedence.
</span></span></span><span class="line"><span class="cl"><span class="cm"> * Otherwise we will assume VPD pages are supported if the
</span></span></span><span class="line"><span class="cl"><span class="cm"> * SCSI level is at least SPC-3 and &#39;skip_vpd_pages&#39; is not set.
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">scsi_device_supports_vpd</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="cm">/* Attempt VPD inquiry if the device blacklist explicitly calls
</span></span></span><span class="line"><span class="cl"><span class="cm">	 * for it.
</span></span></span><span class="line"><span class="cl"><span class="cm">	 */</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">try_vpd_pages</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">	 * Although VPD inquiries can go to SCSI-2 type devices,
</span></span></span><span class="line"><span class="cl"><span class="cm">	 * some USB ones crash on receiving them, and the pages
</span></span></span><span class="line"><span class="cl"><span class="cm">	 * we currently ask for are mandatory for SPC-2 and beyond
</span></span></span><span class="line"><span class="cl"><span class="cm">	 */</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">scsi_level</span> <span class="o">&gt;=</span> <span class="n">SCSI_SPC_2</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">skip_vpd_pages</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>By looking at this function we can presume that <strong>try_vpd_pages</strong> flag is not set and <strong>skip_vpd_pages</strong> is. We can discard checking <strong>scsi_level</strong> because <em>Cruzer Blade</em> is <em>SPC-4</em> compliant:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">$ sg_inq /dev/sdc <span class="p">|</span> head -2
</span></span><span class="line"><span class="cl">  standard INQUIRY:
</span></span><span class="line"><span class="cl">    <span class="nv">PQual</span><span class="o">=</span><span class="m">0</span>  <span class="nv">Device_type</span><span class="o">=</span><span class="m">0</span>  <span class="nv">RMB</span><span class="o">=</span><span class="m">1</span>  <span class="nv">LU_CONG</span><span class="o">=</span><span class="m">0</span>  <span class="nv">version</span><span class="o">=</span>0x06  <span class="o">[</span>SPC-4<span class="o">]</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>By looking at the comment of <em>scsi_device_supports_vpd</em>, some USB devices crash after checking their VPD pages, in this case, it makes sense to not enable VPD for all devices. Although, our <em>SanDisk Cruzer Blade</em> device clearly supports VPD and does not crash.</p>
<p><em>scsi_device_supports_vpd</em> is called in two places: <em>scsi_add_lun</em> and <em>scsi_rescan_device</em>. These callers are common path of device setup, so fixing <em>skip_vpd_pages</em> should be enough.</p>
<p>Let’s <em>grep</em> again in the kernel source code to check where <strong>skip_vpd_pages</strong> is being set:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">$ git grep -l skip_vpd_pages
</span></span><span class="line"><span class="cl">drivers/scsi/scsi.c
</span></span><span class="line"><span class="cl">drivers/scsi/scsi_scan.c
</span></span><span class="line"><span class="cl">drivers/usb/storage/scsiglue.c
</span></span><span class="line"><span class="cl">include/scsi/scsi_device.h
</span></span></code></pre></td></tr></table>
</div>
</div><p>Interesting to see that USB layer setting this flag. Let’s check <a href="https://elixir.bootlin.com/linux/v5.2.8/source/drivers/usb/storage/scsiglue.c#L210">drivers/usb/stoarge/scsiglue.c</a> file:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cm">/* Some devices don&#39;t handle VPD pages correctly */</span>
</span></span><span class="line"><span class="cl"><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">skip_vpd_pages</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>By the code above, which belongs to <em>slave_configure</em> function, USB layer disables VPD for all USB storage devices. Makes sense, since some devices are reported to crash when checking for VPD, as stated before.</p>
<p>But, shouldn’t we add support for <em>SanDisk Cruzer Blade</em> at least? There is a per device mapping with specific flags in SCSI layer that should help to fix this situation, specially regarding <strong>try_vpd_pages</strong>. To add support for <em>SanDisk Cruzer Blade</em>* devices, I submited this <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=4bc022145c939dd3938771535a8074a884aec0f9">patch</a> to the kernel mailing list and it’s now merged:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-diff" data-lang="diff"><span class="line"><span class="cl">  {&#34;LENOVO&#34;, &#34;Universal Xport&#34;, &#34;*&#34;, BLIST_NO_ULD_ATTACH},
</span></span><span class="line"><span class="cl"><span class="gi">+ {&#34;SanDisk&#34;, &#34;Cruzer Blade&#34;, NULL, BLIST_TRY_VPD_PAGES |
</span></span></span><span class="line"><span class="cl"><span class="gi">+  BLIST_INQUIRY_36},
</span></span></span><span class="line"><span class="cl"><span class="gi"></span>  {&#34;SMSC&#34;, &#34;USB 2 HS-CF&#34;, NULL, BLIST_SPARSELUN | BLIST_INQUIRY_36},
</span></span><span class="line"><span class="cl">  ...
</span></span></code></pre></td></tr></table>
</div>
</div><p>The patch adds specific flags that will be checked in SCSI layer and will be applied once the <em>SanDisk Cruzer Blade</em>* device is found. This change alone does not fix the problem as the flag <strong>skip_vpd_pages</strong> is still enabled. So I submited a second <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=349148785b8cea9781af520fd53c29ee8087ee74">patch</a>, to only set <strong>skip_vpd_pages</strong> when <strong>try_vpd_pages</strong> is not set allowing the SCSI layer to process all VPD pages when <strong>try_vpd_pages</strong> is set.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-diff" data-lang="diff"><span class="line"><span class="cl"><span class="gd">-  /* Some devices don&#39;t handle VPD pages correctly */
</span></span></span><span class="line"><span class="cl"><span class="gd">-  sdev-&gt;skip_vpd_pages = 1;
</span></span></span><span class="line"><span class="cl"><span class="gd"></span><span class="gi">+  /*
</span></span></span><span class="line"><span class="cl"><span class="gi">+   * Some devices don&#39;t handle VPD pages correctly, so skip vpd
</span></span></span><span class="line"><span class="cl"><span class="gi">+   * pages if not forced by SCSI layer.
</span></span></span><span class="line"><span class="cl"><span class="gi">+   */
</span></span></span><span class="line"><span class="cl"><span class="gi">+  sdev-&gt;skip_vpd_pages = !sdev-&gt;try_vpd_pages;
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>With these two patches applied <em>SanDisk Cruzer Blade</em> USB flash device is able to properly show the VPD pages in <em>sysfs</em>:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">$ cat /sys/block/sda/device/vendor
</span></span><span class="line"><span class="cl">SanDisk
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$ cat /sys/block/sda/device/model
</span></span><span class="line"><span class="cl">Cruzer Blade
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$ cat /sys/block/sda/device/vpd_pg80
</span></span><span class="line"><span class="cl">4C530001300722111594
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$ cat /sys/block/sda/device/vpd_pg83 
</span></span><span class="line"><span class="cl">0,SanDiskCruzer Blade4C530001300722111594
</span></span></code></pre></td></tr></table>
</div>
</div><p>That’s all for today. Stay tuned for more posts about Kernel and whatnot, see ya!</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
<nav class="paginav">
  <a class="prev" href="https://mpdesouza.com/blog/new-btrfs-feature-delete-subvolumes-using-subvolume-ids/">
    <span class="title">« Prev</span>
    <br>
    <span>New btrfs feature: Delete subvolumes using subvolume ids</span>
  </a>
  <a class="next" href="https://mpdesouza.com/blog/kernel-adventures-are-usb-sticks-rotational-devices/">
    <span class="title">Next »</span>
    <br>
    <span>Kernel Adventures: Are USB Sticks Rotational Devices?</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="https://mpdesouza.com">Marcos&#39; Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
