<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Kernel Adventures: Are USB Sticks Rotational Devices? | Marcos&#39; Blog</title>
<meta name="keywords" content="">
<meta name="description" content="Post about understanding why USB devices are usually set as rotational devices on linux.">
<meta name="author" content="Marcos Paulo de Souza">
<link rel="canonical" href="https://mpdesouza.com/blog/kernel-adventures-are-usb-sticks-rotational-devices/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.3613efbd0b1772781e8f49935e973cae632a7f61471c05b17be155505ccf87b5.css" integrity="sha256-NhPvvQsXcngej0mTXpc8rmMqf2FHHAWxe&#43;FVUFzPh7U=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://mpdesouza.com/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://mpdesouza.com/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://mpdesouza.com/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://mpdesouza.com/apple-touch-icon.png">
<link rel="mask-icon" href="https://mpdesouza.com/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-LWD0KKCW2G"></script>
<script>
var doNotTrack = false;
if (!doNotTrack) {
	window.dataLayer = window.dataLayer || [];
	function gtag(){dataLayer.push(arguments);}
	gtag('js', new Date());
	gtag('config', 'G-LWD0KKCW2G', { 'anonymize_ip': false });
}
</script>
<meta property="og:title" content="Kernel Adventures: Are USB Sticks Rotational Devices?" />
<meta property="og:description" content="Post about understanding why USB devices are usually set as rotational devices on linux." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://mpdesouza.com/blog/kernel-adventures-are-usb-sticks-rotational-devices/" /><meta property="article:section" content="blog" />
<meta property="article:published_time" content="2019-08-07T00:00:00+00:00" />
<meta property="article:modified_time" content="2019-08-07T00:00:00+00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Kernel Adventures: Are USB Sticks Rotational Devices?"/>
<meta name="twitter:description" content="Post about understanding why USB devices are usually set as rotational devices on linux."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Blog",
      "item": "https://mpdesouza.com/blog/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "Kernel Adventures: Are USB Sticks Rotational Devices?",
      "item": "https://mpdesouza.com/blog/kernel-adventures-are-usb-sticks-rotational-devices/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Kernel Adventures: Are USB Sticks Rotational Devices?",
  "name": "Kernel Adventures: Are USB Sticks Rotational Devices?",
  "description": "Post about understanding why USB devices are usually set as rotational devices on linux.",
  "keywords": [
    
  ],
  "articleBody": "A while ago I’ve found this kernel bug entry about USB mass storage being shown as a rotational device. This is wrong because a USB stick is a flash device, and does not rotate.\nAbout rotational devices Let’s take a minute to discuss about the evolution from disk to flash storage.\nOlder storage devices, HDD in this example, were called Disk Storage because these devices recorded data into one or more rotating disks. In such devices, the rotation speed was a feature that informed how fast the device was. A device with 5400 RPM (Rotations Per Minute) was slower than a device with 7200 RPM, for example.\nAn example of a working HDD, a rotational disk. Reference: https://www.behance.net/gallery/25354853/HDD-Animation\nThese devices were known to spend a large amount of time only to position the arm/head of the disk in the right sector/track to read the desired data. If a disk spins faster, so you can get your data faster.\nFlash Storage USB sticks and SSD storage devices are Non-Volatile Memory, which is much faster when compared to the disk storage because they don’t need a mechanical rotational procedure to find the stored data. Data is stored in an array of transistors, and the seek time to find the desired data is constant while seek time can vary in rotational devices due to the position of the head needed to be positioned in different places of storage disk.\nInside of a SSD device. Reference: https://www.backblaze.com/blog/hdd-versus-ssd-whats-the-diff/\nBack to the bug My idea was to check the kernel code in order to understand how it works. First of all, USB mass storage uses SCSI commands to transfer data between host and USB device. With this in mind, there are two layers in kernel to check: SCSI and USB.\nBy looking at Linux kernel code, specifically function sd_revalidate_disk in drivers/scsi/sd.c:\n1 2 3 4 5 6 7 /* * set the default to rotational. All non-rotational devices * support the block characteristics VPD page, which will * cause this to be updated correctly and any device which * doesn’t support it should be treated as rotational. */ blk_queue_flag_clear(QUEUE_FLAG_NONROT, q); This function is called when a disk is detected. It first sets the disk as rotational, by clearing the NONROT flag (yes, it’s confusing at first glance). A few lines bellow this point, we can see the following code:\n1 2 3 4 5 6 if (scsi_device_supports_vpd(sdp)) { sd_read_block_provisioning(sdkp); sd_read_block_limits(sdkp); sd_read_block_characteristics(sdkp); sd_zbc_read_zones(sdkp, buffer); } We need some background about VPD. VPD stands for Vital Product Data, and presents information and configuration about a device, a SCSI device in this case. VPD was introduced in SCSI Primary Commands (SPC) 2 specification, and can be “queried” from any SCSI storage device by using sg_utils3 package:\n1 2 3 4 5 6 7 8 9 $ sg_vpd /dev/sda Supported VPD pages VPD page: Supported VPD pages [sv] Unit serial number [sn] Device identification [di] ATA information (SAT) [ai] Block limits (SBC) [bl] Block device characteristics (SBC) [bdc] Logical block provisioning (SBC) [lbpv] This is the output of my SSD device. Going back to our original problem, rotating USB storage, the function sd_read_block_characteristics does something interesting:\n1 2 3 4 5 6 7 8 9 10 11 if (!buffer || /* Block Device Characteristics VPD */ scsi_get_vpd_page(sdkp-\u003edevice, 0xb1, buffer, vpd_len)) goto out; rot = get_unaligned_be16(buffer[4]); if (rot == 1) { blk_queue_flag_set(QUEUE_FLAG_NONROT, q); blk_queue_flag_clear(QUEUE_FLAG_ADD_RANDOM, q); } The code above reads the Block Device Characteristics VPD page, which is present only in SPC-3 or later. Again, sg_vpd can help us to check BDC:\n1 2 3 4 5 6 7 8 9 10 11 12 13 $ sg_vpd — page bdc /dev/sda Block device characteristics VPD page (SBC): Non-rotating medium (e.g. solid state) Product type: Not specified WABEREQ=0 WACEREQ=0 Nominal form factor not reported ZONED=0 RBWZ=0 BOCS=0 FUAB=0 VBULS=0 DEPOPULATION_TIME=0 (seconds) As you can see, the Block Device Characteristics of my SSD device says clearly: Non-rotation Medium. Per the function above, the NONROT flag will be set, so sysfs will show when reading the rotational attribute of this device:\n1 2 $ cat /sys/block/sda/queue/rotational 0 Moving further, I have another storage disk, now an HDD:\n1 2 3 4 5 6 7 8 9 10 11 12 13 $ sg_vpd — page bdc /dev/sdb Block device characteristics VPD page (SBC): Nominal rotation rate: 5400 rpm Product type: Not specified WABEREQ=0 WACEREQ=0 Nominal form factor not reported ZONED=0 RBWZ=0 BOCS=0 FUAB=0 VBULS=0 DEPOPULATION_TIME=0 (seconds) Nominal rotation rate: 5400 rpm. Indeed, it’s a rotational device. But, what about USB sticks?\nI’ve tested more than 10 USB sticks and USB SATA adapters, and neither of them have BDC exposed. Let’s use sg_inq to check if these which version of SCSI/SPC they implement, and which VPD they expose:\nAlcor Micro Corp. Flash Drive 058f:6387 (USB Stick) 1 2 3 4 5 6 7 8 $ sg_inq -s /dev/sdc standard INQUIRY: PQual=0 Device_type=0 RMB=1 LU_CONG=0 version=0x04 [SPC-2] $ sg_vpd --page 0x0 /dev/sdc Supported VPD pages VPD page: Supported VPD pages [sv] Unit serial number [sn] Device identification [di] Chipsbank Microelectronics Co., Ltd 1e3d:2092 (USB Stick) 1 2 3 4 5 6 7 8 9 $ sg_inq /dev/sdc invalid VPD response; probably a STANDARD INQUIRY response standard INQUIRY: PQual=0 Device_type=0 RMB=1 LU_CONG=0 version=0x02 [SCSI-2] $ sg_vpd --page 0x0 /dev/sdc Supported VPD pages VPD page: invalid VPD response; probably a STANDARD INQUIRY response fetching VPD page failed: Malformed SCSI command sg_vpd failed: Malformed SCSI command This device does not even implements VPD.\nHP, Inc 4 GB flash drive 03f0:3207 (USB stick) 1 2 3 4 5 6 7 8 9 $ sg_inq /dev/sdc invalid VPD response; probably a STANDARD INQUIRY response standard INQUIRY: PQual=0 Device_type=0 RMB=1 LU_CONG=0 version=0x00 [no conformance claimed] $ sg_vpd /dev/sdc Supported VPD pages VPD page: invalid VPD response; probably a STANDARD INQUIRY response fetching VPD page failed: Malformed SCSI command sg_vpd failed: Malformed SCSI command This one is even worse, does not even comply with any specification.\nSanDisk Corp. Cruzer Blade 0781:5567 (USB Stick) 1 2 3 4 5 6 7 8 $ sg_inq /dev/sdc standard INQUIRY: PQual=0 Device_type=0 RMB=1 LU_CONG=0 version=0x06 [SPC-4] $ sg_vpd --page 0x0 /dev/sdc Supported VPD pages VPD page: Supported VPD pages [sv] Unit serial number [sn] Device identification [di] This one from SanDisk complies with SPC-4, but no BDC supported either.\nSuper Top M6116 SATA Bridge 14cd:6116 (USB SATA adapter) 1 2 3 4 5 $ sg_inq /dev/sdc standard INQUIRY: PQual=0 Device_type=0 RMB=0 LU_CONG=0 version=0x00 [no conformance claimed] $ sg_vpd --page 0x0 /dev/sdc Supported VPD pages VPD page: It doesn’t show any VPD, but apprently understands the SCSI INQ command.\nInitio Corporation 13fd:3920 (USB SATA adapter) 1 2 3 4 5 6 7 8 $ sg_inq /dev/sdc standard INQUIRY: PQual=0 Device_type=0 RMB=0 LU_CONG=0 version=0x06 [SPC-4] $ sg_vpd --page 0x0 /dev/sdc Supported VPD pages VPD page: Supported VPD pages [sv] Unit serial number [sn] Device identification [di] Another device which implements SPC-4 and does not expose BDC.\nConclusion Without Block Device Characteristics, the kernel cannot say for sure if the device is rotational or not, so the NONROT flag keeps cleared.\nThe rotational information can be used to change the IO scheduler related to the device, as openSUSE currently does:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 $ cat /usr/lib/udev/rules.d/60-io-scheduler.rules # Set optimal IO schedulers for HDD and SSD ACTION!=\"add\", GOTO=\"scheduler_end\" SUBSYSTEM!=\"block\", GOTO=\"scheduler_end\" # Do not change scheduler if `elevator` cmdline parameter is set IMPORT{cmdline}=\"elevator\" ENV{elevator}==\"?*\", GOTO=\"scheduler_end\" # Determine if BLK-MQ is enabled TEST==\"%S%p/mq\", ENV{.IS_MQ}=\"1\" # MQ: BFQ scheduler for HDD ENV{.IS_MQ}==\"1\", ATTR{queue/rotational}!=\"0\", ATTR{queue/scheduler}=\"bfq\" # MQ: deadline scheduler for SSD ENV{.IS_MQ}==\"1\", ATTR{queue/rotational}==\"0\", ATTR{queue/scheduler}=\"mq-deadline\" # Non-MQ: CFQ scheduler for HDD ENV{.IS_MQ}!=\"1\", ATTR{queue/rotational}!=\"0\", ATTR{queue/scheduler}=\"cfq\" # Non-MQ: deadline scheduler for SSD ENV{.IS_MQ}!=\"1\", ATTR{queue/rotational}==\"0\", ATTR{queue/scheduler}=\"deadline\" LABEL=\"scheduler_end\" Picking the right IO scheduler helps to extract the best performancee of your storage device. For example BFQ IO scheduler would reorder read/write requests, trying to make them contiguous in order to extract the best of performance from an HDD disk. Remember, HDD devices have the head that needs to be positioned in the right place to get your data, and avoiding it to be moved randomly helps to improve performance.\nThe above is true for HDD devices but doesn’t help much SSD devices which don’t have the performance penalty of the seek time, so mq-deadline would be a better solution for this cases. This scheduler prefer reads over writes not reordering requests, and that’s all, making it perform better in SSD devices.\nStay tuned for our next topic about IO schedulers and other things related to block layer. See you next time!\n",
  "wordCount" : "1435",
  "inLanguage": "en",
  "datePublished": "2019-08-07T00:00:00Z",
  "dateModified": "2019-08-07T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "Marcos Paulo de Souza"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://mpdesouza.com/blog/kernel-adventures-are-usb-sticks-rotational-devices/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Marcos' Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://mpdesouza.com/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://mpdesouza.com" accesskey="h" title="Marcos&#39; Blog (Alt + H)">Marcos&#39; Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://mpdesouza.com/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="https://mpdesouza.com/about-me/" title="About Me">
                    <span>About Me</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://mpdesouza.com">Home</a>&nbsp;»&nbsp;<a href="https://mpdesouza.com/blog/">Blog</a></div>
    <h1 class="post-title">
      Kernel Adventures: Are USB Sticks Rotational Devices?
    </h1>
    <div class="post-description">
      Post about understanding why USB devices are usually set as rotational devices on linux.
    </div>
    <div class="post-meta"><span title='2019-08-07 00:00:00 +0000 UTC'>August 7, 2019</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;Marcos Paulo de Souza

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#about-rotational-devices" aria-label="About rotational devices">About rotational devices</a></li>
                <li>
                    <a href="#flash-storage" aria-label="Flash Storage">Flash Storage</a></li>
                <li>
                    <a href="#back-to-the-bug" aria-label="Back to the bug">Back to the bug</a><ul>
                        
                <li>
                    <a href="#alcor-micro-corp-flash-drive-058f6387-usb-stick" aria-label="Alcor Micro Corp. Flash Drive 058f:6387 (USB Stick)">Alcor Micro Corp. Flash Drive 058f:6387 (USB Stick)</a></li>
                <li>
                    <a href="#chipsbank-microelectronics-co-ltd-1e3d2092-usb-stick" aria-label="Chipsbank Microelectronics Co., Ltd 1e3d:2092 (USB Stick)">Chipsbank Microelectronics Co., Ltd 1e3d:2092 (USB Stick)</a></li>
                <li>
                    <a href="#hp-inc-4-gb-flash-drive-03f03207-usb-stick" aria-label="HP, Inc 4 GB flash drive 03f0:3207 (USB stick)">HP, Inc 4 GB flash drive 03f0:3207 (USB stick)</a></li>
                <li>
                    <a href="#sandisk-corp-cruzer-blade-07815567-usb-stick" aria-label="SanDisk Corp. Cruzer Blade 0781:5567 (USB Stick)">SanDisk Corp. Cruzer Blade 0781:5567 (USB Stick)</a></li>
                <li>
                    <a href="#super-top-m6116-sata-bridge-14cd6116-usb-sata-adapter" aria-label="Super Top M6116 SATA Bridge 14cd:6116 (USB SATA adapter)">Super Top M6116 SATA Bridge 14cd:6116 (USB SATA adapter)</a></li>
                <li>
                    <a href="#initio-corporation-13fd3920-usb-sata-adapter" aria-label="Initio Corporation 13fd:3920 (USB SATA adapter)">Initio Corporation 13fd:3920 (USB SATA adapter)</a></li></ul>
                </li>
                <li>
                    <a href="#conclusion" aria-label="Conclusion">Conclusion</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><p>A while ago I’ve found this <a href="https://bugzilla.kernel.org/show_bug.cgi?id=90761">kernel bug entry</a> about USB mass storage being shown as a <em>rotational device</em>. This is wrong because a USB stick is a flash device, and does not <em>rotate</em>.</p>
<h3 id="about-rotational-devices">About rotational devices<a hidden class="anchor" aria-hidden="true" href="#about-rotational-devices">#</a></h3>
<p>Let’s take a minute to discuss about the evolution from disk to flash storage.</p>
<p>Older storage devices, HDD in this example, were called Disk Storage because these devices recorded data into one or more <em>rotating disks</em>. In such devices, the <em>rotation</em> speed was a feature that informed how fast the device was. A device with 5400 <em>RPM</em> (Rotations Per Minute) was slower than a device with 7200 <em>RPM</em>, for example.</p>
<p><img loading="lazy" src="/images/rotational-disk.gif" alt="An example of a working HDD, a rotational disk"  />
</p>
<blockquote>
<p>An example of a working HDD, a rotational disk. Reference: <a href="https://www.behance.net/gallery/25354853/HDD-Animation">https://www.behance.net/gallery/25354853/HDD-Animation</a></p>
</blockquote>
<p>These devices were known to spend a large amount of time only to position the <em>arm/head</em> of the disk in the right sector/track to read the desired data. If a disk spins faster, so you can get your data faster.</p>
<h3 id="flash-storage">Flash Storage<a hidden class="anchor" aria-hidden="true" href="#flash-storage">#</a></h3>
<p>USB sticks and SSD storage devices are <em>Non-Volatile Memory</em>, which is much faster when compared to the disk storage because  they don’t need a mechanical <em>rotational</em> procedure to find the stored data. Data is stored in an array of transistors, and  the seek time to find the desired data is constant while seek time can vary in <em>rotational devices</em> due to the position of the head needed to be positioned in different places of storage disk.</p>
<p><img loading="lazy" src="/images/ssd-inside.jpg" alt="Inside of a SSD device"  />
</p>
<blockquote>
<p>Inside of a SSD device. Reference: <a href="https://www.backblaze.com/blog/hdd-versus-ssd-whats-the-diff/">https://www.backblaze.com/blog/hdd-versus-ssd-whats-the-diff/</a></p>
</blockquote>
<h3 id="back-to-the-bug">Back to the bug<a hidden class="anchor" aria-hidden="true" href="#back-to-the-bug">#</a></h3>
<p>My idea was to check the kernel code in order to understand how it works. First of all, <a href="https://en.wikipedia.org/wiki/USB_mass_storage_device_class">USB mass storage</a> uses <a href="https://en.wikipedia.org/wiki/SCSI_command">SCSI commands</a> to transfer data between host and USB device. With this in mind, there are two layers in kernel to check: SCSI and USB.</p>
<p>By looking at Linux kernel code, specifically function <em>sd_revalidate_disk</em> in <a href="https://elixir.bootlin.com/linux/v5.3-rc1/source/drivers/scsi/sd.c#L3129">drivers/scsi/sd.c</a>:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm"> * set the default to rotational. All non-rotational devices
</span></span></span><span class="line"><span class="cl"><span class="cm"> * support the block characteristics VPD page, which will
</span></span></span><span class="line"><span class="cl"><span class="cm"> * cause this to be updated correctly and any device which
</span></span></span><span class="line"><span class="cl"><span class="cm"> * doesn’t support it should be treated as rotational.
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="nf">blk_queue_flag_clear</span><span class="p">(</span><span class="n">QUEUE_FLAG_NONROT</span><span class="p">,</span> <span class="n">q</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>This function is called when a disk is detected. It first sets the disk as <em>rotational</em>, by clearing the <em>NONROT</em> flag (yes, it’s confusing at first glance). A few lines bellow this point, we can see the following code:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="nf">scsi_device_supports_vpd</span><span class="p">(</span><span class="n">sdp</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nf">sd_read_block_provisioning</span><span class="p">(</span><span class="n">sdkp</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="nf">sd_read_block_limits</span><span class="p">(</span><span class="n">sdkp</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="nf">sd_read_block_characteristics</span><span class="p">(</span><span class="n">sdkp</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="nf">sd_zbc_read_zones</span><span class="p">(</span><span class="n">sdkp</span><span class="p">,</span> <span class="n">buffer</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>We need some background about VPD. VPD stands for <em>Vital Product Data</em>, and presents information and configuration about a device, a SCSI device in this case. VPD was introduced in <strong>SCSI Primary Commands</strong> (SPC) 2 specification, and can be “queried” from any SCSI storage device by using <strong>sg_utils3</strong> package:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="err">$</span> <span class="n">sg_vpd</span> <span class="o">/</span><span class="n">dev</span><span class="o">/</span><span class="n">sda</span> 
</span></span><span class="line"><span class="cl">  <span class="n">Supported</span> <span class="n">VPD</span> <span class="n">pages</span> <span class="n">VPD</span> <span class="nl">page</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">   <span class="n">Supported</span> <span class="n">VPD</span> <span class="n">pages</span> <span class="p">[</span><span class="n">sv</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">   <span class="n">Unit</span> <span class="n">serial</span> <span class="n">number</span> <span class="p">[</span><span class="n">sn</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">   <span class="n">Device</span> <span class="n">identification</span> <span class="p">[</span><span class="n">di</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">   <span class="n">ATA</span> <span class="nf">information</span> <span class="p">(</span><span class="n">SAT</span><span class="p">)</span> <span class="p">[</span><span class="n">ai</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">   <span class="n">Block</span> <span class="nf">limits</span> <span class="p">(</span><span class="n">SBC</span><span class="p">)</span> <span class="p">[</span><span class="n">bl</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">   <span class="n">Block</span> <span class="n">device</span> <span class="nf">characteristics</span> <span class="p">(</span><span class="n">SBC</span><span class="p">)</span> <span class="p">[</span><span class="n">bdc</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">   <span class="n">Logical</span> <span class="n">block</span> <span class="nf">provisioning</span> <span class="p">(</span><span class="n">SBC</span><span class="p">)</span> <span class="p">[</span><span class="n">lbpv</span><span class="p">]</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>This is the output of my SSD device. Going back to our original problem, <em>rotating USB storage</em>, the function <em>sd_read_block_characteristics</em> does something interesting:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer</span> <span class="o">||</span>
</span></span><span class="line"><span class="cl">     <span class="cm">/* Block Device Characteristics VPD */</span>
</span></span><span class="line"><span class="cl">     <span class="nf">scsi_get_vpd_page</span><span class="p">(</span><span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span> <span class="mh">0xb1</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">vpd_len</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl"><span class="n">rot</span> <span class="o">=</span> <span class="nf">get_unaligned_be16</span><span class="p">(</span><span class="n">buffer</span><span class="p">[</span><span class="mi">4</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">rot</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nf">blk_queue_flag_set</span><span class="p">(</span><span class="n">QUEUE_FLAG_NONROT</span><span class="p">,</span> <span class="n">q</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="nf">blk_queue_flag_clear</span><span class="p">(</span><span class="n">QUEUE_FLAG_ADD_RANDOM</span><span class="p">,</span> <span class="n">q</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>The code above reads the <strong>Block Device Characteristics</strong> VPD page, which is present only in <a href="http://www.t10.org/ftp/t10/document.07/07-203r0.pdf">SPC-3</a> or later. Again, sg_vpd can help us to check BDC:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">$ sg_vpd — page bdc /dev/sda
</span></span><span class="line"><span class="cl">  Block device characteristics VPD page <span class="o">(</span>SBC<span class="o">)</span>:
</span></span><span class="line"><span class="cl">   Non-rotating medium <span class="o">(</span>e.g. solid state<span class="o">)</span>
</span></span><span class="line"><span class="cl">   Product type: Not specified
</span></span><span class="line"><span class="cl">   <span class="nv">WABEREQ</span><span class="o">=</span><span class="m">0</span>
</span></span><span class="line"><span class="cl">   <span class="nv">WACEREQ</span><span class="o">=</span><span class="m">0</span>
</span></span><span class="line"><span class="cl">   Nominal form factor not reported
</span></span><span class="line"><span class="cl">   <span class="nv">ZONED</span><span class="o">=</span><span class="m">0</span>
</span></span><span class="line"><span class="cl">   <span class="nv">RBWZ</span><span class="o">=</span><span class="m">0</span>
</span></span><span class="line"><span class="cl">   <span class="nv">BOCS</span><span class="o">=</span><span class="m">0</span>
</span></span><span class="line"><span class="cl">   <span class="nv">FUAB</span><span class="o">=</span><span class="m">0</span>
</span></span><span class="line"><span class="cl">   <span class="nv">VBULS</span><span class="o">=</span><span class="m">0</span>
</span></span><span class="line"><span class="cl">   <span class="nv">DEPOPULATION_TIME</span><span class="o">=</span><span class="m">0</span> <span class="o">(</span>seconds<span class="o">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>As you can see, the <strong>Block Device Characteristics</strong> of my SSD device says clearly: <strong>Non-rotation Medium</strong>. Per the function above, the NONROT flag will be set, so <em>sysfs</em> will show when reading the rotational attribute of this device:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">$ cat /sys/block/sda/queue/rotational 
</span></span><span class="line"><span class="cl"><span class="m">0</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Moving further, I have another storage disk, now an HDD:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">$ sg_vpd  — page bdc /dev/sdb 
</span></span><span class="line"><span class="cl">  Block device characteristics VPD page <span class="o">(</span>SBC<span class="o">)</span>:
</span></span><span class="line"><span class="cl">   Nominal rotation rate: <span class="m">5400</span> rpm
</span></span><span class="line"><span class="cl">   Product type: Not specified
</span></span><span class="line"><span class="cl">   <span class="nv">WABEREQ</span><span class="o">=</span><span class="m">0</span>
</span></span><span class="line"><span class="cl">   <span class="nv">WACEREQ</span><span class="o">=</span><span class="m">0</span>
</span></span><span class="line"><span class="cl">   Nominal form factor not reported
</span></span><span class="line"><span class="cl">   <span class="nv">ZONED</span><span class="o">=</span><span class="m">0</span>
</span></span><span class="line"><span class="cl">   <span class="nv">RBWZ</span><span class="o">=</span><span class="m">0</span>
</span></span><span class="line"><span class="cl">   <span class="nv">BOCS</span><span class="o">=</span><span class="m">0</span>
</span></span><span class="line"><span class="cl">   <span class="nv">FUAB</span><span class="o">=</span><span class="m">0</span>
</span></span><span class="line"><span class="cl">   <span class="nv">VBULS</span><span class="o">=</span><span class="m">0</span>
</span></span><span class="line"><span class="cl">   <span class="nv">DEPOPULATION_TIME</span><span class="o">=</span><span class="m">0</span> <span class="o">(</span>seconds<span class="o">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>Nominal rotation rate: 5400 rpm</strong>. Indeed, it’s a rotational device. But, what about USB sticks?</p>
<p>I’ve tested more than 10 USB sticks and USB SATA adapters, and neither of them have BDC exposed. Let’s use <strong>sg_inq</strong> to check if these which version of SCSI/SPC they implement, and which VPD they expose:</p>
<h4 id="alcor-micro-corp-flash-drive-058f6387-usb-stick">Alcor Micro Corp. Flash Drive 058f:6387 (USB Stick)<a hidden class="anchor" aria-hidden="true" href="#alcor-micro-corp-flash-drive-058f6387-usb-stick">#</a></h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">$ sg_inq -s /dev/sdc
</span></span><span class="line"><span class="cl">  standard INQUIRY:
</span></span><span class="line"><span class="cl">    <span class="nv">PQual</span><span class="o">=</span><span class="m">0</span>  <span class="nv">Device_type</span><span class="o">=</span><span class="m">0</span>  <span class="nv">RMB</span><span class="o">=</span><span class="m">1</span>  <span class="nv">LU_CONG</span><span class="o">=</span><span class="m">0</span>  <span class="nv">version</span><span class="o">=</span>0x04  <span class="o">[</span>SPC-2<span class="o">]</span>
</span></span><span class="line"><span class="cl">$ sg_vpd --page 0x0 /dev/sdc
</span></span><span class="line"><span class="cl">  Supported VPD pages VPD page:
</span></span><span class="line"><span class="cl">    Supported VPD pages <span class="o">[</span>sv<span class="o">]</span>
</span></span><span class="line"><span class="cl">    Unit serial number <span class="o">[</span>sn<span class="o">]</span>
</span></span><span class="line"><span class="cl">    Device identification <span class="o">[</span>di<span class="o">]</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="chipsbank-microelectronics-co-ltd-1e3d2092-usb-stick">Chipsbank Microelectronics Co., Ltd 1e3d:2092 (USB Stick)<a hidden class="anchor" aria-hidden="true" href="#chipsbank-microelectronics-co-ltd-1e3d2092-usb-stick">#</a></h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">$ sg_inq /dev/sdc
</span></span><span class="line"><span class="cl">  invalid VPD response<span class="p">;</span> probably a STANDARD INQUIRY response
</span></span><span class="line"><span class="cl">  standard INQUIRY:
</span></span><span class="line"><span class="cl">    <span class="nv">PQual</span><span class="o">=</span><span class="m">0</span>  <span class="nv">Device_type</span><span class="o">=</span><span class="m">0</span>  <span class="nv">RMB</span><span class="o">=</span><span class="m">1</span>  <span class="nv">LU_CONG</span><span class="o">=</span><span class="m">0</span>  <span class="nv">version</span><span class="o">=</span>0x02  <span class="o">[</span>SCSI-2<span class="o">]</span>
</span></span><span class="line"><span class="cl">$ sg_vpd --page 0x0 /dev/sdc
</span></span><span class="line"><span class="cl">  Supported VPD pages VPD page:
</span></span><span class="line"><span class="cl">  invalid VPD response<span class="p">;</span> probably a STANDARD INQUIRY response
</span></span><span class="line"><span class="cl">  fetching VPD page failed: Malformed SCSI <span class="nb">command</span>
</span></span><span class="line"><span class="cl">  sg_vpd failed: Malformed SCSI <span class="nb">command</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>This device does not even implements VPD.</p>
<h4 id="hp-inc-4-gb-flash-drive-03f03207-usb-stick">HP, Inc 4 GB flash drive 03f0:3207 (USB stick)<a hidden class="anchor" aria-hidden="true" href="#hp-inc-4-gb-flash-drive-03f03207-usb-stick">#</a></h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">$ sg_inq /dev/sdc
</span></span><span class="line"><span class="cl">  invalid VPD response<span class="p">;</span> probably a STANDARD INQUIRY response
</span></span><span class="line"><span class="cl">  standard INQUIRY:
</span></span><span class="line"><span class="cl">    <span class="nv">PQual</span><span class="o">=</span><span class="m">0</span>  <span class="nv">Device_type</span><span class="o">=</span><span class="m">0</span>  <span class="nv">RMB</span><span class="o">=</span><span class="m">1</span>  <span class="nv">LU_CONG</span><span class="o">=</span><span class="m">0</span>  <span class="nv">version</span><span class="o">=</span>0x00  <span class="o">[</span>no conformance claimed<span class="o">]</span>
</span></span><span class="line"><span class="cl">$ sg_vpd /dev/sdc
</span></span><span class="line"><span class="cl">  Supported VPD pages VPD page:
</span></span><span class="line"><span class="cl">  invalid VPD response<span class="p">;</span> probably a STANDARD INQUIRY response
</span></span><span class="line"><span class="cl">  fetching VPD page failed: Malformed SCSI <span class="nb">command</span>
</span></span><span class="line"><span class="cl">  sg_vpd failed: Malformed SCSI <span class="nb">command</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>This one is even worse, does not even comply with any specification.</p>
<h4 id="sandisk-corp-cruzer-blade-07815567-usb-stick">SanDisk Corp. Cruzer Blade 0781:5567 (USB Stick)<a hidden class="anchor" aria-hidden="true" href="#sandisk-corp-cruzer-blade-07815567-usb-stick">#</a></h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">$ sg_inq /dev/sdc
</span></span><span class="line"><span class="cl">  standard INQUIRY:
</span></span><span class="line"><span class="cl">    <span class="nv">PQual</span><span class="o">=</span><span class="m">0</span>  <span class="nv">Device_type</span><span class="o">=</span><span class="m">0</span>  <span class="nv">RMB</span><span class="o">=</span><span class="m">1</span>  <span class="nv">LU_CONG</span><span class="o">=</span><span class="m">0</span>  <span class="nv">version</span><span class="o">=</span>0x06  <span class="o">[</span>SPC-4<span class="o">]</span>
</span></span><span class="line"><span class="cl">$ sg_vpd --page 0x0 /dev/sdc
</span></span><span class="line"><span class="cl">  Supported VPD pages VPD page:
</span></span><span class="line"><span class="cl">    Supported VPD pages <span class="o">[</span>sv<span class="o">]</span>
</span></span><span class="line"><span class="cl">    Unit serial number <span class="o">[</span>sn<span class="o">]</span>
</span></span><span class="line"><span class="cl">    Device identification <span class="o">[</span>di<span class="o">]</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>This one from SanDisk complies with SPC-4, but no BDC supported either.</p>
<h4 id="super-top-m6116-sata-bridge-14cd6116-usb-sata-adapter">Super Top M6116 SATA Bridge 14cd:6116 (USB SATA adapter)<a hidden class="anchor" aria-hidden="true" href="#super-top-m6116-sata-bridge-14cd6116-usb-sata-adapter">#</a></h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">$ sg_inq /dev/sdc
</span></span><span class="line"><span class="cl">  standard INQUIRY:
</span></span><span class="line"><span class="cl">    <span class="nv">PQual</span><span class="o">=</span><span class="m">0</span>  <span class="nv">Device_type</span><span class="o">=</span><span class="m">0</span>  <span class="nv">RMB</span><span class="o">=</span><span class="m">0</span>  <span class="nv">LU_CONG</span><span class="o">=</span><span class="m">0</span>  <span class="nv">version</span><span class="o">=</span>0x00  <span class="o">[</span>no conformance claimed<span class="o">]</span>
</span></span><span class="line"><span class="cl">$ sg_vpd --page 0x0 /dev/sdc
</span></span><span class="line"><span class="cl">  Supported VPD pages VPD page:
</span></span></code></pre></td></tr></table>
</div>
</div><p>It doesn’t show any VPD, but apprently understands the SCSI INQ command.</p>
<h4 id="initio-corporation-13fd3920-usb-sata-adapter">Initio Corporation 13fd:3920 (USB SATA adapter)<a hidden class="anchor" aria-hidden="true" href="#initio-corporation-13fd3920-usb-sata-adapter">#</a></h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">$ sg_inq /dev/sdc           
</span></span><span class="line"><span class="cl">  standard INQUIRY:
</span></span><span class="line"><span class="cl">    <span class="nv">PQual</span><span class="o">=</span><span class="m">0</span>  <span class="nv">Device_type</span><span class="o">=</span><span class="m">0</span>  <span class="nv">RMB</span><span class="o">=</span><span class="m">0</span>  <span class="nv">LU_CONG</span><span class="o">=</span><span class="m">0</span>  <span class="nv">version</span><span class="o">=</span>0x06  <span class="o">[</span>SPC-4<span class="o">]</span>
</span></span><span class="line"><span class="cl">$ sg_vpd --page 0x0 /dev/sdc
</span></span><span class="line"><span class="cl">  Supported VPD pages VPD page:
</span></span><span class="line"><span class="cl">    Supported VPD pages <span class="o">[</span>sv<span class="o">]</span>
</span></span><span class="line"><span class="cl">    Unit serial number <span class="o">[</span>sn<span class="o">]</span>
</span></span><span class="line"><span class="cl">    Device identification <span class="o">[</span>di<span class="o">]</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Another device which implements SPC-4 and does not expose BDC.</p>
<h3 id="conclusion">Conclusion<a hidden class="anchor" aria-hidden="true" href="#conclusion">#</a></h3>
<p>Without Block Device Characteristics, the kernel cannot say for sure if the device is rotational or not, so the <em>NONROT</em> flag keeps cleared.</p>
<p>The <em>rotational</em> information can be used to change the IO scheduler related to the device, as openSUSE currently does:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">$ cat /usr/lib/udev/rules.d/60-io-scheduler.rules
</span></span><span class="line"><span class="cl">  <span class="c1"># Set optimal IO schedulers for HDD and SSD</span>
</span></span><span class="line"><span class="cl">  ACTION!<span class="o">=</span><span class="s2">&#34;add&#34;</span>, <span class="nv">GOTO</span><span class="o">=</span><span class="s2">&#34;scheduler_end&#34;</span>
</span></span><span class="line"><span class="cl">  SUBSYSTEM!<span class="o">=</span><span class="s2">&#34;block&#34;</span>, <span class="nv">GOTO</span><span class="o">=</span><span class="s2">&#34;scheduler_end&#34;</span>
</span></span><span class="line"><span class="cl">  <span class="c1"># Do not change scheduler if `elevator` cmdline parameter is set</span>
</span></span><span class="line"><span class="cl">  IMPORT<span class="o">{</span>cmdline<span class="o">}=</span><span class="s2">&#34;elevator&#34;</span>
</span></span><span class="line"><span class="cl">  ENV<span class="o">{</span>elevator<span class="o">}==</span><span class="s2">&#34;?*&#34;</span>, <span class="nv">GOTO</span><span class="o">=</span><span class="s2">&#34;scheduler_end&#34;</span>
</span></span><span class="line"><span class="cl">  <span class="c1"># Determine if BLK-MQ is enabled</span>
</span></span><span class="line"><span class="cl">  <span class="nv">TEST</span><span class="o">==</span><span class="s2">&#34;%S%p/mq&#34;</span>, ENV<span class="o">{</span>.IS_MQ<span class="o">}=</span><span class="s2">&#34;1&#34;</span>
</span></span><span class="line"><span class="cl">  <span class="c1"># MQ: BFQ scheduler for HDD</span>
</span></span><span class="line"><span class="cl">  ENV<span class="o">{</span>.IS_MQ<span class="o">}==</span><span class="s2">&#34;1&#34;</span>, ATTR<span class="o">{</span>queue/rotational<span class="o">}</span>!<span class="o">=</span><span class="s2">&#34;0&#34;</span>, ATTR<span class="o">{</span>queue/scheduler<span class="o">}=</span><span class="s2">&#34;bfq&#34;</span>
</span></span><span class="line"><span class="cl">  <span class="c1"># MQ: deadline scheduler for SSD</span>
</span></span><span class="line"><span class="cl">  ENV<span class="o">{</span>.IS_MQ<span class="o">}==</span><span class="s2">&#34;1&#34;</span>, ATTR<span class="o">{</span>queue/rotational<span class="o">}==</span><span class="s2">&#34;0&#34;</span>, ATTR<span class="o">{</span>queue/scheduler<span class="o">}=</span><span class="s2">&#34;mq-deadline&#34;</span>
</span></span><span class="line"><span class="cl">  <span class="c1"># Non-MQ: CFQ scheduler for HDD</span>
</span></span><span class="line"><span class="cl">  ENV<span class="o">{</span>.IS_MQ<span class="o">}</span>!<span class="o">=</span><span class="s2">&#34;1&#34;</span>, ATTR<span class="o">{</span>queue/rotational<span class="o">}</span>!<span class="o">=</span><span class="s2">&#34;0&#34;</span>, ATTR<span class="o">{</span>queue/scheduler<span class="o">}=</span><span class="s2">&#34;cfq&#34;</span>
</span></span><span class="line"><span class="cl">  <span class="c1"># Non-MQ: deadline scheduler for SSD</span>
</span></span><span class="line"><span class="cl">  ENV<span class="o">{</span>.IS_MQ<span class="o">}</span>!<span class="o">=</span><span class="s2">&#34;1&#34;</span>, ATTR<span class="o">{</span>queue/rotational<span class="o">}==</span><span class="s2">&#34;0&#34;</span>, ATTR<span class="o">{</span>queue/scheduler<span class="o">}=</span><span class="s2">&#34;deadline&#34;</span>
</span></span><span class="line"><span class="cl">  <span class="nv">LABEL</span><span class="o">=</span><span class="s2">&#34;scheduler_end&#34;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Picking the right IO scheduler helps to extract the best performancee of your storage device. For example BFQ IO scheduler would reorder <em>read</em>/<em>write</em> requests, trying to make them contiguous in order to extract the best of performance from an HDD disk. Remember, HDD devices have the <em>head</em> that needs to be positioned in the right place to get your data, and avoiding it to be moved randomly helps to improve performance.</p>
<p>The above is true for HDD devices but doesn’t help much SSD devices which don’t have the performance penalty of the seek time, so <em>mq-deadline</em> would be a better solution for this cases. This scheduler prefer <em>reads</em> over <em>writes</em> not reordering requests, and that’s all, making it perform better in SSD devices.</p>
<p>Stay tuned for our next topic about IO schedulers and other things related to block layer. See you next time!</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
<nav class="paginav">
  <a class="prev" href="https://mpdesouza.com/blog/kernel-adventures-enabling-vpd-pages-for-usb-storage-devices-in-sysfs/">
    <span class="title">« Prev</span>
    <br>
    <span>Kernel Adventures: Enabling VPD Pages for USB Storage Devices in sysfs</span>
  </a>
  <a class="next" href="https://mpdesouza.com/blog/no_new_privs-avoiding-privilege-escalation/">
    <span class="title">Next »</span>
    <br>
    <span>NO_NEW_PRIVS: avoiding privilege escalation</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="https://mpdesouza.com">Marcos&#39; Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
